// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import type {
  CreateClientOptions,
  Headers,
  Host,
  QueryParameters,
  Request,
  RequestOptions,
} from '@algolia/client-common';
import { createAuth, createTransporter, getAlgoliaAgent } from '@algolia/client-common';

import type { Authentication } from '../model/authentication';
import type { AuthenticationCreate } from '../model/authenticationCreate';
import type { AuthenticationCreateResponse } from '../model/authenticationCreateResponse';
import type { AuthenticationSearch } from '../model/authenticationSearch';

import type { AuthenticationUpdateResponse } from '../model/authenticationUpdateResponse';
import type { DeleteResponse } from '../model/deleteResponse';
import type { Destination } from '../model/destination';
import type { DestinationCreate } from '../model/destinationCreate';
import type { DestinationCreateResponse } from '../model/destinationCreateResponse';
import type { DestinationSearch } from '../model/destinationSearch';

import type { DestinationUpdateResponse } from '../model/destinationUpdateResponse';

import type { Event } from '../model/event';

import type { ListAuthenticationsResponse } from '../model/listAuthenticationsResponse';
import type { ListDestinationsResponse } from '../model/listDestinationsResponse';
import type { ListEventsResponse } from '../model/listEventsResponse';
import type { ListSourcesResponse } from '../model/listSourcesResponse';
import type { ListTasksResponse } from '../model/listTasksResponse';
import type { ListTasksResponseV1 } from '../model/listTasksResponseV1';
import type { ListTransformationsResponse } from '../model/listTransformationsResponse';

import type { Run } from '../model/run';
import type { RunListResponse } from '../model/runListResponse';
import type { RunResponse } from '../model/runResponse';

import type { RunSourceResponse } from '../model/runSourceResponse';

import type { Source } from '../model/source';
import type { SourceCreate } from '../model/sourceCreate';
import type { SourceCreateResponse } from '../model/sourceCreateResponse';
import type { SourceSearch } from '../model/sourceSearch';

import type { SourceUpdateResponse } from '../model/sourceUpdateResponse';
import type { Task } from '../model/task';
import type { TaskCreate } from '../model/taskCreate';
import type { TaskCreateResponse } from '../model/taskCreateResponse';
import type { TaskCreateV1 } from '../model/taskCreateV1';
import type { TaskSearch } from '../model/taskSearch';

import type { TaskUpdateResponse } from '../model/taskUpdateResponse';

import type { TaskV1 } from '../model/taskV1';
import type { Transformation } from '../model/transformation';
import type { TransformationCreate } from '../model/transformationCreate';
import type { TransformationCreateResponse } from '../model/transformationCreateResponse';
import type { TransformationSearch } from '../model/transformationSearch';

import type { TransformationTry } from '../model/transformationTry';
import type { TransformationTryResponse } from '../model/transformationTryResponse';
import type { TransformationUpdateResponse } from '../model/transformationUpdateResponse';

import type { WatchResponse } from '../model/watchResponse';

import type {
  CustomDeleteProps,
  CustomGetProps,
  CustomPostProps,
  CustomPutProps,
  DeleteAuthenticationProps,
  DeleteDestinationProps,
  DeleteSourceProps,
  DeleteTaskProps,
  DeleteTaskV1Props,
  DeleteTransformationProps,
  DisableTaskProps,
  DisableTaskV1Props,
  EnableTaskProps,
  EnableTaskV1Props,
  GetAuthenticationProps,
  GetDestinationProps,
  GetEventProps,
  GetRunProps,
  GetSourceProps,
  GetTaskProps,
  GetTaskV1Props,
  GetTransformationProps,
  ListAuthenticationsProps,
  ListDestinationsProps,
  ListEventsProps,
  ListRunsProps,
  ListSourcesProps,
  ListTasksProps,
  ListTasksV1Props,
  ListTransformationsProps,
  PushTaskProps,
  RunSourceProps,
  RunTaskProps,
  RunTaskV1Props,
  TriggerDockerSourceDiscoverProps,
  TryTransformationBeforeUpdateProps,
  UpdateAuthenticationProps,
  UpdateDestinationProps,
  UpdateSourceProps,
  UpdateTaskProps,
  UpdateTaskV1Props,
  UpdateTransformationProps,
  ValidateSourceBeforeUpdateProps,
} from '../model/clientMethodProps';

import type { OnDemandTrigger } from '../model/onDemandTrigger';
import type { ScheduleTrigger } from '../model/scheduleTrigger';
import type { SubscriptionTrigger } from '../model/subscriptionTrigger';
import type { TaskCreateTrigger } from '../model/taskCreateTrigger';
import type { Trigger } from '../model/trigger';

export const apiClientVersion = '1.20.3';

export const REGIONS = ['eu', 'us'] as const;
export type Region = (typeof REGIONS)[number];
export type RegionOptions = { region: Region };

function getDefaultHosts(region: Region): Host[] {
  const url = 'data.{region}.algolia.com'.replace('{region}', region);

  return [{ url, accept: 'readWrite', protocol: 'https' }];
}

/**
 * Guard: Return strongly typed specific OnDemandTrigger for a given Trigger.
 *
 * @summary Guard method that returns a strongly typed specific OnDemandTrigger for a given Trigger.
 * @param trigger - The given Task Trigger.
 */
export function isOnDemandTrigger(trigger: TaskCreateTrigger | Trigger): trigger is OnDemandTrigger {
  return trigger.type === 'onDemand';
}

/**
 * Guard: Return strongly typed specific ScheduleTrigger for a given Trigger.
 *
 * @summary Guard method that returns a strongly typed specific ScheduleTrigger for a given Trigger.
 * @param trigger - The given Task Trigger.
 */
export function isScheduleTrigger(trigger: TaskCreateTrigger | Trigger): trigger is ScheduleTrigger {
  return trigger.type === 'schedule';
}

/**
 * Guard: Return strongly typed specific SubscriptionTrigger for a given Trigger.
 *
 * @summary Guard method that returns a strongly typed specific SubscriptionTrigger for a given Trigger.
 * @param trigger - The given Task Trigger.
 */
export function isSubscriptionTrigger(trigger: TaskCreateTrigger | Trigger): trigger is SubscriptionTrigger {
  return trigger.type === 'subscription';
}

export function createIngestionClient({
  appId: appIdOption,
  apiKey: apiKeyOption,
  authMode,
  algoliaAgents,
  region: regionOption,
  ...options
}: CreateClientOptions & RegionOptions) {
  const auth = createAuth(appIdOption, apiKeyOption, authMode);
  const transporter = createTransporter({
    hosts: getDefaultHosts(regionOption),
    ...options,
    algoliaAgent: getAlgoliaAgent({
      algoliaAgents,
      client: 'Ingestion',
      version: apiClientVersion,
    }),
    baseHeaders: {
      'content-type': 'text/plain',
      ...auth.headers(),
      ...options.baseHeaders,
    },
    baseQueryParameters: {
      ...auth.queryParameters(),
      ...options.baseQueryParameters,
    },
  });

  return {
    transporter,

    /**
     * The `appId` currently in use.
     */
    appId: appIdOption,

    /**
     * The `apiKey` currently in use.
     */
    apiKey: apiKeyOption,

    /**
     * Clears the cache of the transporter for the `requestsCache` and `responsesCache` properties.
     */
    clearCache(): Promise<void> {
      return Promise.all([transporter.requestsCache.clear(), transporter.responsesCache.clear()]).then(() => undefined);
    },

    /**
     * Get the value of the `algoliaAgent`, used by our libraries internally and telemetry system.
     */
    get _ua(): string {
      return transporter.algoliaAgent.value;
    },

    /**
     * Adds a `segment` to the `x-algolia-agent` sent with every requests.
     *
     * @param segment - The algolia agent (user-agent) segment to add.
     * @param version - The version of the agent.
     */
    addAlgoliaAgent(segment: string, version?: string): void {
      transporter.algoliaAgent.add({ segment, version });
    },

    /**
     * Helper method to switch the API key used to authenticate the requests.
     *
     * @param params - Method params.
     * @param params.apiKey - The new API Key to use.
     */
    setClientApiKey({ apiKey }: { apiKey: string }): void {
      if (!authMode || authMode === 'WithinHeaders') {
        transporter.baseHeaders['x-algolia-api-key'] = apiKey;
      } else {
        transporter.baseQueryParameters['x-algolia-api-key'] = apiKey;
      }
    },

    /**
     * Creates a new authentication resource.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param authenticationCreate -
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createAuthentication(
      authenticationCreate: AuthenticationCreate,
      requestOptions?: RequestOptions,
    ): Promise<AuthenticationCreateResponse> {
      if (!authenticationCreate) {
        throw new Error('Parameter `authenticationCreate` is required when calling `createAuthentication`.');
      }

      if (!authenticationCreate.type) {
        throw new Error('Parameter `authenticationCreate.type` is required when calling `createAuthentication`.');
      }
      if (!authenticationCreate.name) {
        throw new Error('Parameter `authenticationCreate.name` is required when calling `createAuthentication`.');
      }
      if (!authenticationCreate.input) {
        throw new Error('Parameter `authenticationCreate.input` is required when calling `createAuthentication`.');
      }

      const requestPath = '/1/authentications';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: authenticationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new destination.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param destinationCreate -
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createDestination(
      destinationCreate: DestinationCreate,
      requestOptions?: RequestOptions,
    ): Promise<DestinationCreateResponse> {
      if (!destinationCreate) {
        throw new Error('Parameter `destinationCreate` is required when calling `createDestination`.');
      }

      if (!destinationCreate.type) {
        throw new Error('Parameter `destinationCreate.type` is required when calling `createDestination`.');
      }
      if (!destinationCreate.name) {
        throw new Error('Parameter `destinationCreate.name` is required when calling `createDestination`.');
      }
      if (!destinationCreate.input) {
        throw new Error('Parameter `destinationCreate.input` is required when calling `createDestination`.');
      }

      const requestPath = '/1/destinations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: destinationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new source.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param sourceCreate -
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createSource(sourceCreate: SourceCreate, requestOptions?: RequestOptions): Promise<SourceCreateResponse> {
      if (!sourceCreate) {
        throw new Error('Parameter `sourceCreate` is required when calling `createSource`.');
      }

      if (!sourceCreate.type) {
        throw new Error('Parameter `sourceCreate.type` is required when calling `createSource`.');
      }
      if (!sourceCreate.name) {
        throw new Error('Parameter `sourceCreate.name` is required when calling `createSource`.');
      }

      const requestPath = '/1/sources';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new task.
     * @param taskCreate - Request body for creating a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createTask(taskCreate: TaskCreate, requestOptions?: RequestOptions): Promise<TaskCreateResponse> {
      if (!taskCreate) {
        throw new Error('Parameter `taskCreate` is required when calling `createTask`.');
      }

      if (!taskCreate.sourceID) {
        throw new Error('Parameter `taskCreate.sourceID` is required when calling `createTask`.');
      }
      if (!taskCreate.destinationID) {
        throw new Error('Parameter `taskCreate.destinationID` is required when calling `createTask`.');
      }
      if (!taskCreate.action) {
        throw new Error('Parameter `taskCreate.action` is required when calling `createTask`.');
      }

      const requestPath = '/2/tasks';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: taskCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new task using the v1 endpoint, please use `createTask` instead.
     * @param taskCreate - Request body for creating a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createTaskV1(taskCreate: TaskCreateV1, requestOptions?: RequestOptions): Promise<TaskCreateResponse> {
      if (!taskCreate) {
        throw new Error('Parameter `taskCreate` is required when calling `createTaskV1`.');
      }

      if (!taskCreate.sourceID) {
        throw new Error('Parameter `taskCreate.sourceID` is required when calling `createTaskV1`.');
      }
      if (!taskCreate.destinationID) {
        throw new Error('Parameter `taskCreate.destinationID` is required when calling `createTaskV1`.');
      }
      if (!taskCreate.trigger) {
        throw new Error('Parameter `taskCreate.trigger` is required when calling `createTaskV1`.');
      }
      if (!taskCreate.action) {
        throw new Error('Parameter `taskCreate.action` is required when calling `createTaskV1`.');
      }

      const requestPath = '/1/tasks';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: taskCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new transformation.
     * @param transformationCreate - Request body for creating a transformation.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createTransformation(
      transformationCreate: TransformationCreate,
      requestOptions?: RequestOptions,
    ): Promise<TransformationCreateResponse> {
      if (!transformationCreate) {
        throw new Error('Parameter `transformationCreate` is required when calling `createTransformation`.');
      }

      if (!transformationCreate.code) {
        throw new Error('Parameter `transformationCreate.code` is required when calling `createTransformation`.');
      }
      if (!transformationCreate.name) {
        throw new Error('Parameter `transformationCreate.name` is required when calling `createTransformation`.');
      }

      const requestPath = '/1/transformations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     * @param customDelete - The customDelete object.
     * @param customDelete.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customDelete.parameters - Query parameters to apply to the current query.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customDelete(
      { path, parameters }: CustomDeleteProps,
      requestOptions?: RequestOptions,
    ): Promise<Record<string, unknown>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `customDelete`.');
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     * @param customGet - The customGet object.
     * @param customGet.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customGet.parameters - Query parameters to apply to the current query.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customGet({ path, parameters }: CustomGetProps, requestOptions?: RequestOptions): Promise<Record<string, unknown>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `customGet`.');
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     * @param customPost - The customPost object.
     * @param customPost.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customPost.parameters - Query parameters to apply to the current query.
     * @param customPost.body - Parameters to send with the custom request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customPost(
      { path, parameters, body }: CustomPostProps,
      requestOptions?: RequestOptions,
    ): Promise<Record<string, unknown>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `customPost`.');
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     * @param customPut - The customPut object.
     * @param customPut.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customPut.parameters - Query parameters to apply to the current query.
     * @param customPut.body - Parameters to send with the custom request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customPut(
      { path, parameters, body }: CustomPutProps,
      requestOptions?: RequestOptions,
    ): Promise<Record<string, unknown>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `customPut`.');
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes an authentication resource. You can\'t delete authentication resources that are used by a source or a destination.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param deleteAuthentication - The deleteAuthentication object.
     * @param deleteAuthentication.authenticationID - Unique identifier of an authentication resource.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteAuthentication(
      { authenticationID }: DeleteAuthenticationProps,
      requestOptions?: RequestOptions,
    ): Promise<DeleteResponse> {
      if (!authenticationID) {
        throw new Error('Parameter `authenticationID` is required when calling `deleteAuthentication`.');
      }

      const requestPath = '/1/authentications/{authenticationID}'.replace(
        '{authenticationID}',
        encodeURIComponent(authenticationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a destination by its ID. You can\'t delete destinations that are referenced in tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param deleteDestination - The deleteDestination object.
     * @param deleteDestination.destinationID - Unique identifier of a destination.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteDestination(
      { destinationID }: DeleteDestinationProps,
      requestOptions?: RequestOptions,
    ): Promise<DeleteResponse> {
      if (!destinationID) {
        throw new Error('Parameter `destinationID` is required when calling `deleteDestination`.');
      }

      const requestPath = '/1/destinations/{destinationID}'.replace(
        '{destinationID}',
        encodeURIComponent(destinationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a source by its ID. You can\'t delete sources that are referenced in tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param deleteSource - The deleteSource object.
     * @param deleteSource.sourceID - Unique identifier of a source.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteSource({ sourceID }: DeleteSourceProps, requestOptions?: RequestOptions): Promise<DeleteResponse> {
      if (!sourceID) {
        throw new Error('Parameter `sourceID` is required when calling `deleteSource`.');
      }

      const requestPath = '/1/sources/{sourceID}'.replace('{sourceID}', encodeURIComponent(sourceID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a task by its ID.
     * @param deleteTask - The deleteTask object.
     * @param deleteTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteTask({ taskID }: DeleteTaskProps, requestOptions?: RequestOptions): Promise<DeleteResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `deleteTask`.');
      }

      const requestPath = '/2/tasks/{taskID}'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.
     * @param deleteTaskV1 - The deleteTaskV1 object.
     * @param deleteTaskV1.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteTaskV1({ taskID }: DeleteTaskV1Props, requestOptions?: RequestOptions): Promise<DeleteResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `deleteTaskV1`.');
      }

      const requestPath = '/1/tasks/{taskID}'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a transformation by its ID.
     * @param deleteTransformation - The deleteTransformation object.
     * @param deleteTransformation.transformationID - Unique identifier of a transformation.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteTransformation(
      { transformationID }: DeleteTransformationProps,
      requestOptions?: RequestOptions,
    ): Promise<DeleteResponse> {
      if (!transformationID) {
        throw new Error('Parameter `transformationID` is required when calling `deleteTransformation`.');
      }

      const requestPath = '/1/transformations/{transformationID}'.replace(
        '{transformationID}',
        encodeURIComponent(transformationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Disables a task.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param disableTask - The disableTask object.
     * @param disableTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    disableTask({ taskID }: DisableTaskProps, requestOptions?: RequestOptions): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `disableTask`.');
      }

      const requestPath = '/2/tasks/{taskID}/disable'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Disables a task using the v1 endpoint, please use `disableTask` instead.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param disableTaskV1 - The disableTaskV1 object.
     * @param disableTaskV1.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    disableTaskV1({ taskID }: DisableTaskV1Props, requestOptions?: RequestOptions): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `disableTaskV1`.');
      }

      const requestPath = '/1/tasks/{taskID}/disable'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Enables a task.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param enableTask - The enableTask object.
     * @param enableTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    enableTask({ taskID }: EnableTaskProps, requestOptions?: RequestOptions): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `enableTask`.');
      }

      const requestPath = '/2/tasks/{taskID}/enable'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Enables a task using the v1 endpoint, please use `enableTask` instead.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param enableTaskV1 - The enableTaskV1 object.
     * @param enableTaskV1.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    enableTaskV1({ taskID }: EnableTaskV1Props, requestOptions?: RequestOptions): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `enableTaskV1`.');
      }

      const requestPath = '/1/tasks/{taskID}/enable'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves an authentication resource by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getAuthentication - The getAuthentication object.
     * @param getAuthentication.authenticationID - Unique identifier of an authentication resource.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getAuthentication(
      { authenticationID }: GetAuthenticationProps,
      requestOptions?: RequestOptions,
    ): Promise<Authentication> {
      if (!authenticationID) {
        throw new Error('Parameter `authenticationID` is required when calling `getAuthentication`.');
      }

      const requestPath = '/1/authentications/{authenticationID}'.replace(
        '{authenticationID}',
        encodeURIComponent(authenticationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a destination by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getDestination - The getDestination object.
     * @param getDestination.destinationID - Unique identifier of a destination.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getDestination({ destinationID }: GetDestinationProps, requestOptions?: RequestOptions): Promise<Destination> {
      if (!destinationID) {
        throw new Error('Parameter `destinationID` is required when calling `getDestination`.');
      }

      const requestPath = '/1/destinations/{destinationID}'.replace(
        '{destinationID}',
        encodeURIComponent(destinationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a single task run event by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getEvent - The getEvent object.
     * @param getEvent.runID - Unique identifier of a task run.
     * @param getEvent.eventID - Unique identifier of an event.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getEvent({ runID, eventID }: GetEventProps, requestOptions?: RequestOptions): Promise<Event> {
      if (!runID) {
        throw new Error('Parameter `runID` is required when calling `getEvent`.');
      }

      if (!eventID) {
        throw new Error('Parameter `eventID` is required when calling `getEvent`.');
      }

      const requestPath = '/1/runs/{runID}/events/{eventID}'
        .replace('{runID}', encodeURIComponent(runID))
        .replace('{eventID}', encodeURIComponent(eventID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve a single task run by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getRun - The getRun object.
     * @param getRun.runID - Unique identifier of a task run.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getRun({ runID }: GetRunProps, requestOptions?: RequestOptions): Promise<Run> {
      if (!runID) {
        throw new Error('Parameter `runID` is required when calling `getRun`.');
      }

      const requestPath = '/1/runs/{runID}'.replace('{runID}', encodeURIComponent(runID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve a source by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getSource - The getSource object.
     * @param getSource.sourceID - Unique identifier of a source.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getSource({ sourceID }: GetSourceProps, requestOptions?: RequestOptions): Promise<Source> {
      if (!sourceID) {
        throw new Error('Parameter `sourceID` is required when calling `getSource`.');
      }

      const requestPath = '/1/sources/{sourceID}'.replace('{sourceID}', encodeURIComponent(sourceID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a task by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getTask - The getTask object.
     * @param getTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTask({ taskID }: GetTaskProps, requestOptions?: RequestOptions): Promise<Task> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `getTask`.');
      }

      const requestPath = '/2/tasks/{taskID}'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getTaskV1 - The getTaskV1 object.
     * @param getTaskV1.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTaskV1({ taskID }: GetTaskV1Props, requestOptions?: RequestOptions): Promise<TaskV1> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `getTaskV1`.');
      }

      const requestPath = '/1/tasks/{taskID}'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a transformation by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param getTransformation - The getTransformation object.
     * @param getTransformation.transformationID - Unique identifier of a transformation.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTransformation(
      { transformationID }: GetTransformationProps,
      requestOptions?: RequestOptions,
    ): Promise<Transformation> {
      if (!transformationID) {
        throw new Error('Parameter `transformationID` is required when calling `getTransformation`.');
      }

      const requestPath = '/1/transformations/{transformationID}'.replace(
        '{transformationID}',
        encodeURIComponent(transformationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of all authentication resources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listAuthentications - The listAuthentications object.
     * @param listAuthentications.itemsPerPage - Number of items per page.
     * @param listAuthentications.page - Page number of the paginated API response.
     * @param listAuthentications.type - Type of authentication resource to retrieve.
     * @param listAuthentications.platform - Ecommerce platform for which to retrieve authentications.
     * @param listAuthentications.sort - Property by which to sort the list of authentications.
     * @param listAuthentications.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listAuthentications(
      { itemsPerPage, page, type, platform, sort, order }: ListAuthenticationsProps = {},
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<ListAuthenticationsResponse> {
      const requestPath = '/1/authentications';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (type !== undefined) {
        queryParameters['type'] = type.toString();
      }

      if (platform !== undefined) {
        queryParameters['platform'] = platform.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of destinations.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listDestinations - The listDestinations object.
     * @param listDestinations.itemsPerPage - Number of items per page.
     * @param listDestinations.page - Page number of the paginated API response.
     * @param listDestinations.type - Destination type.
     * @param listDestinations.authenticationID - Authentication ID used by destinations.
     * @param listDestinations.transformationID - Get the list of destinations used by a transformation.
     * @param listDestinations.sort - Property by which to sort the destinations.
     * @param listDestinations.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listDestinations(
      { itemsPerPage, page, type, authenticationID, transformationID, sort, order }: ListDestinationsProps = {},
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<ListDestinationsResponse> {
      const requestPath = '/1/destinations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (type !== undefined) {
        queryParameters['type'] = type.toString();
      }

      if (authenticationID !== undefined) {
        queryParameters['authenticationID'] = authenticationID.toString();
      }

      if (transformationID !== undefined) {
        queryParameters['transformationID'] = transformationID.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of events for a task run, identified by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listEvents - The listEvents object.
     * @param listEvents.runID - Unique identifier of a task run.
     * @param listEvents.itemsPerPage - Number of items per page.
     * @param listEvents.page - Page number of the paginated API response.
     * @param listEvents.status - Event status for filtering the list of task runs.
     * @param listEvents.type - Event type for filtering the list of task runs.
     * @param listEvents.sort - Property by which to sort the list of task run events.
     * @param listEvents.order - Sort order of the response, ascending or descending.
     * @param listEvents.startDate - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
     * @param listEvents.endDate - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listEvents(
      { runID, itemsPerPage, page, status, type, sort, order, startDate, endDate }: ListEventsProps,
      requestOptions?: RequestOptions,
    ): Promise<ListEventsResponse> {
      if (!runID) {
        throw new Error('Parameter `runID` is required when calling `listEvents`.');
      }

      const requestPath = '/1/runs/{runID}/events'.replace('{runID}', encodeURIComponent(runID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (status !== undefined) {
        queryParameters['status'] = status.toString();
      }

      if (type !== undefined) {
        queryParameters['type'] = type.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      if (startDate !== undefined) {
        queryParameters['startDate'] = startDate.toString();
      }

      if (endDate !== undefined) {
        queryParameters['endDate'] = endDate.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve a list of task runs.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listRuns - The listRuns object.
     * @param listRuns.itemsPerPage - Number of items per page.
     * @param listRuns.page - Page number of the paginated API response.
     * @param listRuns.status - Run status for filtering the list of task runs.
     * @param listRuns.type - Run type for filtering the list of task runs.
     * @param listRuns.taskID - Task ID for filtering the list of task runs.
     * @param listRuns.sort - Property by which to sort the list of task runs.
     * @param listRuns.order - Sort order of the response, ascending or descending.
     * @param listRuns.startDate - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
     * @param listRuns.endDate - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listRuns(
      { itemsPerPage, page, status, type, taskID, sort, order, startDate, endDate }: ListRunsProps = {},
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<RunListResponse> {
      const requestPath = '/1/runs';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (status !== undefined) {
        queryParameters['status'] = status.toString();
      }

      if (type !== undefined) {
        queryParameters['type'] = type.toString();
      }

      if (taskID !== undefined) {
        queryParameters['taskID'] = taskID.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      if (startDate !== undefined) {
        queryParameters['startDate'] = startDate.toString();
      }

      if (endDate !== undefined) {
        queryParameters['endDate'] = endDate.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of sources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listSources - The listSources object.
     * @param listSources.itemsPerPage - Number of items per page.
     * @param listSources.page - Page number of the paginated API response.
     * @param listSources.type - Source type. Some sources require authentication.
     * @param listSources.authenticationID - Authentication IDs of the sources to retrieve. \'none\' returns sources that doesn\'t have an authentication.
     * @param listSources.sort - Property by which to sort the list of sources.
     * @param listSources.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listSources(
      { itemsPerPage, page, type, authenticationID, sort, order }: ListSourcesProps = {},
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<ListSourcesResponse> {
      const requestPath = '/1/sources';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (type !== undefined) {
        queryParameters['type'] = type.toString();
      }

      if (authenticationID !== undefined) {
        queryParameters['authenticationID'] = authenticationID.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listTasks - The listTasks object.
     * @param listTasks.itemsPerPage - Number of items per page.
     * @param listTasks.page - Page number of the paginated API response.
     * @param listTasks.action - Actions for filtering the list of tasks.
     * @param listTasks.enabled - Whether to filter the list of tasks by the `enabled` status.
     * @param listTasks.sourceID - Source IDs for filtering the list of tasks.
     * @param listTasks.sourceType - Filters the tasks with the specified source type.
     * @param listTasks.destinationID - Destination IDs for filtering the list of tasks.
     * @param listTasks.triggerType - Type of task trigger for filtering the list of tasks.
     * @param listTasks.withEmailNotifications - If specified, the response only includes tasks with notifications.email.enabled set to this value.
     * @param listTasks.sort - Property by which to sort the list of tasks.
     * @param listTasks.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listTasks(
      {
        itemsPerPage,
        page,
        action,
        enabled,
        sourceID,
        sourceType,
        destinationID,
        triggerType,
        withEmailNotifications,
        sort,
        order,
      }: ListTasksProps = {},
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<ListTasksResponse> {
      const requestPath = '/2/tasks';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (action !== undefined) {
        queryParameters['action'] = action.toString();
      }

      if (enabled !== undefined) {
        queryParameters['enabled'] = enabled.toString();
      }

      if (sourceID !== undefined) {
        queryParameters['sourceID'] = sourceID.toString();
      }

      if (sourceType !== undefined) {
        queryParameters['sourceType'] = sourceType.toString();
      }

      if (destinationID !== undefined) {
        queryParameters['destinationID'] = destinationID.toString();
      }

      if (triggerType !== undefined) {
        queryParameters['triggerType'] = triggerType.toString();
      }

      if (withEmailNotifications !== undefined) {
        queryParameters['withEmailNotifications'] = withEmailNotifications.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listTasksV1 - The listTasksV1 object.
     * @param listTasksV1.itemsPerPage - Number of items per page.
     * @param listTasksV1.page - Page number of the paginated API response.
     * @param listTasksV1.action - Actions for filtering the list of tasks.
     * @param listTasksV1.enabled - Whether to filter the list of tasks by the `enabled` status.
     * @param listTasksV1.sourceID - Source IDs for filtering the list of tasks.
     * @param listTasksV1.destinationID - Destination IDs for filtering the list of tasks.
     * @param listTasksV1.triggerType - Type of task trigger for filtering the list of tasks.
     * @param listTasksV1.sort - Property by which to sort the list of tasks.
     * @param listTasksV1.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listTasksV1(
      { itemsPerPage, page, action, enabled, sourceID, destinationID, triggerType, sort, order }: ListTasksV1Props = {},
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<ListTasksResponseV1> {
      const requestPath = '/1/tasks';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (action !== undefined) {
        queryParameters['action'] = action.toString();
      }

      if (enabled !== undefined) {
        queryParameters['enabled'] = enabled.toString();
      }

      if (sourceID !== undefined) {
        queryParameters['sourceID'] = sourceID.toString();
      }

      if (destinationID !== undefined) {
        queryParameters['destinationID'] = destinationID.toString();
      }

      if (triggerType !== undefined) {
        queryParameters['triggerType'] = triggerType.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of transformations.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param listTransformations - The listTransformations object.
     * @param listTransformations.itemsPerPage - Number of items per page.
     * @param listTransformations.page - Page number of the paginated API response.
     * @param listTransformations.sort - Property by which to sort the list of transformations.
     * @param listTransformations.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listTransformations(
      { itemsPerPage, page, sort, order }: ListTransformationsProps = {},
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<ListTransformationsResponse> {
      const requestPath = '/1/transformations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters['itemsPerPage'] = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters['page'] = page.toString();
      }

      if (sort !== undefined) {
        queryParameters['sort'] = sort.toString();
      }

      if (order !== undefined) {
        queryParameters['order'] = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Push a `batch` request payload through the Pipeline. You can check the status of task pushes with the observability endpoints.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param pushTask - The pushTask object.
     * @param pushTask.taskID - Unique identifier of a task.
     * @param pushTask.pushTaskPayload - Request body of a Search API `batch` request that will be pushed in the Connectors pipeline.
     * @param pushTask.watch - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    pushTask(
      { taskID, pushTaskPayload, watch }: PushTaskProps,
      requestOptions?: RequestOptions,
    ): Promise<WatchResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `pushTask`.');
      }

      if (!pushTaskPayload) {
        throw new Error('Parameter `pushTaskPayload` is required when calling `pushTask`.');
      }

      if (!pushTaskPayload.action) {
        throw new Error('Parameter `pushTaskPayload.action` is required when calling `pushTask`.');
      }
      if (!pushTaskPayload.records) {
        throw new Error('Parameter `pushTaskPayload.records` is required when calling `pushTask`.');
      }

      const requestPath = '/2/tasks/{taskID}/push'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (watch !== undefined) {
        queryParameters['watch'] = watch.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: pushTaskPayload,
      };

      requestOptions = {
        timeouts: {
          connect: 180000,
          read: 180000,
          write: 180000,
          ...requestOptions?.timeouts,
        },
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Runs all tasks linked to a source, only available for Shopify sources. It will create 1 run per task.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param runSource - The runSource object.
     * @param runSource.sourceID - Unique identifier of a source.
     * @param runSource.runSourcePayload -
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    runSource(
      { sourceID, runSourcePayload }: RunSourceProps,
      requestOptions?: RequestOptions,
    ): Promise<RunSourceResponse> {
      if (!sourceID) {
        throw new Error('Parameter `sourceID` is required when calling `runSource`.');
      }

      const requestPath = '/1/sources/{sourceID}/run'.replace('{sourceID}', encodeURIComponent(sourceID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: runSourcePayload ? runSourcePayload : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Runs a task. You can check the status of task runs with the observability endpoints.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param runTask - The runTask object.
     * @param runTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    runTask({ taskID }: RunTaskProps, requestOptions?: RequestOptions): Promise<RunResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `runTask`.');
      }

      const requestPath = '/2/tasks/{taskID}/run'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param runTaskV1 - The runTaskV1 object.
     * @param runTaskV1.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    runTaskV1({ taskID }: RunTaskV1Props, requestOptions?: RequestOptions): Promise<RunResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `runTaskV1`.');
      }

      const requestPath = '/1/tasks/{taskID}/run'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for authentication resources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param authenticationSearch - The authenticationSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchAuthentications(
      authenticationSearch: AuthenticationSearch,
      requestOptions?: RequestOptions,
    ): Promise<Array<Authentication>> {
      if (!authenticationSearch) {
        throw new Error('Parameter `authenticationSearch` is required when calling `searchAuthentications`.');
      }

      if (!authenticationSearch.authenticationIDs) {
        throw new Error(
          'Parameter `authenticationSearch.authenticationIDs` is required when calling `searchAuthentications`.',
        );
      }

      const requestPath = '/1/authentications/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: authenticationSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for destinations.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param destinationSearch - The destinationSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchDestinations(
      destinationSearch: DestinationSearch,
      requestOptions?: RequestOptions,
    ): Promise<Array<Destination>> {
      if (!destinationSearch) {
        throw new Error('Parameter `destinationSearch` is required when calling `searchDestinations`.');
      }

      if (!destinationSearch.destinationIDs) {
        throw new Error('Parameter `destinationSearch.destinationIDs` is required when calling `searchDestinations`.');
      }

      const requestPath = '/1/destinations/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: destinationSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for sources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param sourceSearch - The sourceSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchSources(sourceSearch: SourceSearch, requestOptions?: RequestOptions): Promise<Array<Source>> {
      if (!sourceSearch) {
        throw new Error('Parameter `sourceSearch` is required when calling `searchSources`.');
      }

      if (!sourceSearch.sourceIDs) {
        throw new Error('Parameter `sourceSearch.sourceIDs` is required when calling `searchSources`.');
      }

      const requestPath = '/1/sources/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param taskSearch - The taskSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchTasks(taskSearch: TaskSearch, requestOptions?: RequestOptions): Promise<Array<Task>> {
      if (!taskSearch) {
        throw new Error('Parameter `taskSearch` is required when calling `searchTasks`.');
      }

      if (!taskSearch.taskIDs) {
        throw new Error('Parameter `taskSearch.taskIDs` is required when calling `searchTasks`.');
      }

      const requestPath = '/2/tasks/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: taskSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param taskSearch - The taskSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchTasksV1(taskSearch: TaskSearch, requestOptions?: RequestOptions): Promise<Array<TaskV1>> {
      if (!taskSearch) {
        throw new Error('Parameter `taskSearch` is required when calling `searchTasksV1`.');
      }

      if (!taskSearch.taskIDs) {
        throw new Error('Parameter `taskSearch.taskIDs` is required when calling `searchTasksV1`.');
      }

      const requestPath = '/1/tasks/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: taskSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for transformations.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param transformationSearch - The transformationSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchTransformations(
      transformationSearch: TransformationSearch,
      requestOptions?: RequestOptions,
    ): Promise<Array<Transformation>> {
      if (!transformationSearch) {
        throw new Error('Parameter `transformationSearch` is required when calling `searchTransformations`.');
      }

      if (!transformationSearch.transformationIDs) {
        throw new Error(
          'Parameter `transformationSearch.transformationIDs` is required when calling `searchTransformations`.',
        );
      }

      const requestPath = '/1/transformations/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Triggers a stream-listing request for a source. Triggering stream-listing requests only works with sources with `type: docker` and `imageType: airbyte`.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param triggerDockerSourceDiscover - The triggerDockerSourceDiscover object.
     * @param triggerDockerSourceDiscover.sourceID - Unique identifier of a source.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    triggerDockerSourceDiscover(
      { sourceID }: TriggerDockerSourceDiscoverProps,
      requestOptions?: RequestOptions,
    ): Promise<WatchResponse> {
      if (!sourceID) {
        throw new Error('Parameter `sourceID` is required when calling `triggerDockerSourceDiscover`.');
      }

      const requestPath = '/1/sources/{sourceID}/discover'.replace('{sourceID}', encodeURIComponent(sourceID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      requestOptions = {
        timeouts: {
          connect: 180000,
          read: 180000,
          write: 180000,
          ...requestOptions?.timeouts,
        },
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Try a transformation before creating it.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param transformationTry - The transformationTry object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    tryTransformation(
      transformationTry: TransformationTry,
      requestOptions?: RequestOptions,
    ): Promise<TransformationTryResponse> {
      if (!transformationTry) {
        throw new Error('Parameter `transformationTry` is required when calling `tryTransformation`.');
      }

      if (!transformationTry.code) {
        throw new Error('Parameter `transformationTry.code` is required when calling `tryTransformation`.');
      }
      if (!transformationTry.sampleRecord) {
        throw new Error('Parameter `transformationTry.sampleRecord` is required when calling `tryTransformation`.');
      }

      const requestPath = '/1/transformations/try';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationTry,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Try a transformation before updating it.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param tryTransformationBeforeUpdate - The tryTransformationBeforeUpdate object.
     * @param tryTransformationBeforeUpdate.transformationID - Unique identifier of a transformation.
     * @param tryTransformationBeforeUpdate.transformationTry - The transformationTry object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    tryTransformationBeforeUpdate(
      { transformationID, transformationTry }: TryTransformationBeforeUpdateProps,
      requestOptions?: RequestOptions,
    ): Promise<TransformationTryResponse> {
      if (!transformationID) {
        throw new Error('Parameter `transformationID` is required when calling `tryTransformationBeforeUpdate`.');
      }

      if (!transformationTry) {
        throw new Error('Parameter `transformationTry` is required when calling `tryTransformationBeforeUpdate`.');
      }

      if (!transformationTry.code) {
        throw new Error('Parameter `transformationTry.code` is required when calling `tryTransformationBeforeUpdate`.');
      }
      if (!transformationTry.sampleRecord) {
        throw new Error(
          'Parameter `transformationTry.sampleRecord` is required when calling `tryTransformationBeforeUpdate`.',
        );
      }

      const requestPath = '/1/transformations/{transformationID}/try'.replace(
        '{transformationID}',
        encodeURIComponent(transformationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationTry,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates an authentication resource.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param updateAuthentication - The updateAuthentication object.
     * @param updateAuthentication.authenticationID - Unique identifier of an authentication resource.
     * @param updateAuthentication.authenticationUpdate - The authenticationUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateAuthentication(
      { authenticationID, authenticationUpdate }: UpdateAuthenticationProps,
      requestOptions?: RequestOptions,
    ): Promise<AuthenticationUpdateResponse> {
      if (!authenticationID) {
        throw new Error('Parameter `authenticationID` is required when calling `updateAuthentication`.');
      }

      if (!authenticationUpdate) {
        throw new Error('Parameter `authenticationUpdate` is required when calling `updateAuthentication`.');
      }

      const requestPath = '/1/authentications/{authenticationID}'.replace(
        '{authenticationID}',
        encodeURIComponent(authenticationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: authenticationUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates the destination by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param updateDestination - The updateDestination object.
     * @param updateDestination.destinationID - Unique identifier of a destination.
     * @param updateDestination.destinationUpdate - The destinationUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateDestination(
      { destinationID, destinationUpdate }: UpdateDestinationProps,
      requestOptions?: RequestOptions,
    ): Promise<DestinationUpdateResponse> {
      if (!destinationID) {
        throw new Error('Parameter `destinationID` is required when calling `updateDestination`.');
      }

      if (!destinationUpdate) {
        throw new Error('Parameter `destinationUpdate` is required when calling `updateDestination`.');
      }

      const requestPath = '/1/destinations/{destinationID}'.replace(
        '{destinationID}',
        encodeURIComponent(destinationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: destinationUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates a source by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param updateSource - The updateSource object.
     * @param updateSource.sourceID - Unique identifier of a source.
     * @param updateSource.sourceUpdate - The sourceUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateSource(
      { sourceID, sourceUpdate }: UpdateSourceProps,
      requestOptions?: RequestOptions,
    ): Promise<SourceUpdateResponse> {
      if (!sourceID) {
        throw new Error('Parameter `sourceID` is required when calling `updateSource`.');
      }

      if (!sourceUpdate) {
        throw new Error('Parameter `sourceUpdate` is required when calling `updateSource`.');
      }

      const requestPath = '/1/sources/{sourceID}'.replace('{sourceID}', encodeURIComponent(sourceID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates a task by its ID.
     * @param updateTask - The updateTask object.
     * @param updateTask.taskID - Unique identifier of a task.
     * @param updateTask.taskUpdate - The taskUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateTask({ taskID, taskUpdate }: UpdateTaskProps, requestOptions?: RequestOptions): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `updateTask`.');
      }

      if (!taskUpdate) {
        throw new Error('Parameter `taskUpdate` is required when calling `updateTask`.');
      }

      const requestPath = '/2/tasks/{taskID}'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: taskUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.
     * @param updateTaskV1 - The updateTaskV1 object.
     * @param updateTaskV1.taskID - Unique identifier of a task.
     * @param updateTaskV1.taskUpdate - The taskUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateTaskV1(
      { taskID, taskUpdate }: UpdateTaskV1Props,
      requestOptions?: RequestOptions,
    ): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error('Parameter `taskID` is required when calling `updateTaskV1`.');
      }

      if (!taskUpdate) {
        throw new Error('Parameter `taskUpdate` is required when calling `updateTaskV1`.');
      }

      const requestPath = '/1/tasks/{taskID}'.replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: taskUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates a transformation by its ID.
     * @param updateTransformation - The updateTransformation object.
     * @param updateTransformation.transformationID - Unique identifier of a transformation.
     * @param updateTransformation.transformationCreate - The transformationCreate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateTransformation(
      { transformationID, transformationCreate }: UpdateTransformationProps,
      requestOptions?: RequestOptions,
    ): Promise<TransformationUpdateResponse> {
      if (!transformationID) {
        throw new Error('Parameter `transformationID` is required when calling `updateTransformation`.');
      }

      if (!transformationCreate) {
        throw new Error('Parameter `transformationCreate` is required when calling `updateTransformation`.');
      }

      if (!transformationCreate.code) {
        throw new Error('Parameter `transformationCreate.code` is required when calling `updateTransformation`.');
      }
      if (!transformationCreate.name) {
        throw new Error('Parameter `transformationCreate.name` is required when calling `updateTransformation`.');
      }

      const requestPath = '/1/transformations/{transformationID}'.replace(
        '{transformationID}',
        encodeURIComponent(transformationID),
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param sourceCreate -
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    validateSource(
      sourceCreate: SourceCreate,
      requestOptions: RequestOptions | undefined = undefined,
    ): Promise<WatchResponse> {
      const requestPath = '/1/sources/validate';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceCreate ? sourceCreate : {},
      };

      requestOptions = {
        timeouts: {
          connect: 180000,
          read: 180000,
          write: 180000,
          ...requestOptions?.timeouts,
        },
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     * @param validateSourceBeforeUpdate - The validateSourceBeforeUpdate object.
     * @param validateSourceBeforeUpdate.sourceID - Unique identifier of a source.
     * @param validateSourceBeforeUpdate.sourceUpdate - The sourceUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    validateSourceBeforeUpdate(
      { sourceID, sourceUpdate }: ValidateSourceBeforeUpdateProps,
      requestOptions?: RequestOptions,
    ): Promise<WatchResponse> {
      if (!sourceID) {
        throw new Error('Parameter `sourceID` is required when calling `validateSourceBeforeUpdate`.');
      }

      if (!sourceUpdate) {
        throw new Error('Parameter `sourceUpdate` is required when calling `validateSourceBeforeUpdate`.');
      }

      const requestPath = '/1/sources/{sourceID}/validate'.replace('{sourceID}', encodeURIComponent(sourceID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceUpdate,
      };

      requestOptions = {
        timeouts: {
          connect: 180000,
          read: 180000,
          write: 180000,
          ...requestOptions?.timeouts,
        },
      };

      return transporter.request(request, requestOptions);
    },
  };
}
