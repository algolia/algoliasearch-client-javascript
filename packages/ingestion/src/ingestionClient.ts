// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import {
  createAuth,
  createTransporter,
  getAlgoliaAgent,
} from '@algolia/client-common';
import type {
  CreateClientOptions,
  Headers,
  Host,
  QueryParameters,
  Request,
  RequestOptions,
} from '@algolia/client-common';

import type { Authentication } from '../model/authentication';
import type { AuthenticationCreate } from '../model/authenticationCreate';
import type { AuthenticationCreateResponse } from '../model/authenticationCreateResponse';
import type { AuthenticationSearch } from '../model/authenticationSearch';
import type { AuthenticationUpdateResponse } from '../model/authenticationUpdateResponse';
import type {
  CustomDeleteProps,
  CustomGetProps,
  CustomPostProps,
  CustomPutProps,
  DeleteAuthenticationProps,
  DeleteDestinationProps,
  DeleteSourceProps,
  DeleteTaskProps,
  DeleteTransformationProps,
  DisableTaskProps,
  EnableTaskProps,
  GetAuthenticationProps,
  GetAuthenticationsProps,
  GetDestinationProps,
  GetDestinationsProps,
  GetEventProps,
  GetEventsProps,
  GetRunProps,
  GetRunsProps,
  GetSourceProps,
  GetSourcesProps,
  GetTaskProps,
  GetTasksProps,
  GetTransformationProps,
  GetTransformationsProps,
  RunTaskProps,
  TriggerDockerSourceDiscoverProps,
  UpdateAuthenticationProps,
  UpdateDestinationProps,
  UpdateSourceProps,
  UpdateTaskProps,
  UpdateTransformationProps,
  ValidateSourceBeforeUpdateProps,
} from '../model/clientMethodProps';
import type { DeleteResponse } from '../model/deleteResponse';
import type { Destination } from '../model/destination';
import type { DestinationCreate } from '../model/destinationCreate';
import type { DestinationCreateResponse } from '../model/destinationCreateResponse';
import type { DestinationSearch } from '../model/destinationSearch';
import type { DestinationUpdateResponse } from '../model/destinationUpdateResponse';
import type { Event } from '../model/event';
import type { ListAuthenticationsResponse } from '../model/listAuthenticationsResponse';
import type { ListDestinationsResponse } from '../model/listDestinationsResponse';
import type { ListEventsResponse } from '../model/listEventsResponse';
import type { ListSourcesResponse } from '../model/listSourcesResponse';
import type { ListTasksResponse } from '../model/listTasksResponse';
import type { ListTransformationsResponse } from '../model/listTransformationsResponse';
import type { OnDemandTrigger } from '../model/onDemandTrigger';
import type { Run } from '../model/run';
import type { RunListResponse } from '../model/runListResponse';
import type { RunResponse } from '../model/runResponse';
import type { ScheduleTrigger } from '../model/scheduleTrigger';
import type { Source } from '../model/source';
import type { SourceCreate } from '../model/sourceCreate';
import type { SourceCreateResponse } from '../model/sourceCreateResponse';
import type { SourceSearch } from '../model/sourceSearch';
import type { SourceUpdateResponse } from '../model/sourceUpdateResponse';
import type { SourceWatchResponse } from '../model/sourceWatchResponse';
import type { SubscriptionTrigger } from '../model/subscriptionTrigger';
import type { Task } from '../model/task';
import type { TaskCreate } from '../model/taskCreate';
import type { TaskCreateResponse } from '../model/taskCreateResponse';
import type { TaskCreateTrigger } from '../model/taskCreateTrigger';
import type { TaskSearch } from '../model/taskSearch';
import type { TaskUpdateResponse } from '../model/taskUpdateResponse';
import type { Transformation } from '../model/transformation';
import type { TransformationCreate } from '../model/transformationCreate';
import type { TransformationCreateResponse } from '../model/transformationCreateResponse';
import type { TransformationSearch } from '../model/transformationSearch';
import type { TransformationTry } from '../model/transformationTry';
import type { TransformationTryResponse } from '../model/transformationTryResponse';
import type { TransformationUpdateResponse } from '../model/transformationUpdateResponse';
import type { Trigger } from '../model/trigger';

export const apiClientVersion = '1.0.0-beta.8';

export const REGIONS = ['eu', 'us'] as const;
export type Region = (typeof REGIONS)[number];

function getDefaultHosts(region: Region): Host[] {
  const url = 'data.{region}.algolia.com'.replace('{region}', region);

  return [{ url, accept: 'readWrite', protocol: 'https' }];
}

/**
 * Guard: Return strongly typed specific OnDemandTrigger for a given Trigger.
 *
 * @summary Guard method that returns a strongly typed specific OnDemandTrigger for a given Trigger.
 * @param trigger - The given Task Trigger.
 */
export function isOnDemandTrigger(
  trigger: TaskCreateTrigger | Trigger
): trigger is OnDemandTrigger {
  return trigger.type === 'onDemand';
}

/**
 * Guard: Return strongly typed specific ScheduleTrigger for a given Trigger.
 *
 * @summary Guard method that returns a strongly typed specific ScheduleTrigger for a given Trigger.
 * @param trigger - The given Task Trigger.
 */
export function isScheduleTrigger(
  trigger: TaskCreateTrigger | Trigger
): trigger is ScheduleTrigger {
  return trigger.type === 'schedule';
}

/**
 * Guard: Return strongly typed specific SubscriptionTrigger for a given Trigger.
 *
 * @summary Guard method that returns a strongly typed specific SubscriptionTrigger for a given Trigger.
 * @param trigger - The given Task Trigger.
 */
export function isSubscriptionTrigger(
  trigger: TaskCreateTrigger | Trigger
): trigger is SubscriptionTrigger {
  return trigger.type === 'subscription';
}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function createIngestionClient({
  appId: appIdOption,
  apiKey: apiKeyOption,
  authMode,
  algoliaAgents,
  region: regionOption,
  ...options
}: CreateClientOptions & { region: Region }) {
  const auth = createAuth(appIdOption, apiKeyOption, authMode);
  const transporter = createTransporter({
    hosts: getDefaultHosts(regionOption),
    ...options,
    algoliaAgent: getAlgoliaAgent({
      algoliaAgents,
      client: 'Ingestion',
      version: apiClientVersion,
    }),
    baseHeaders: {
      'content-type': 'text/plain',
      ...auth.headers(),
      ...options.baseHeaders,
    },
    baseQueryParameters: {
      ...auth.queryParameters(),
      ...options.baseQueryParameters,
    },
  });

  return {
    transporter,

    /**
     * The `appId` currently in use.
     */
    appId: appIdOption,

    /**
     * Clears the cache of the transporter for the `requestsCache` and `responsesCache` properties.
     */
    clearCache(): Promise<void> {
      return Promise.all([
        transporter.requestsCache.clear(),
        transporter.responsesCache.clear(),
      ]).then(() => undefined);
    },

    /**
     * Get the value of the `algoliaAgent`, used by our libraries internally and telemetry system.
     */
    get _ua(): string {
      return transporter.algoliaAgent.value;
    },

    /**
     * Adds a `segment` to the `x-algolia-agent` sent with every requests.
     *
     * @param segment - The algolia agent (user-agent) segment to add.
     * @param version - The version of the agent.
     */
    addAlgoliaAgent(segment: string, version?: string): void {
      transporter.algoliaAgent.add({ segment, version });
    },

    /**
     * Creates a new authentication resource.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param authenticationCreate -.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createAuthentication(
      authenticationCreate: AuthenticationCreate,
      requestOptions?: RequestOptions
    ): Promise<AuthenticationCreateResponse> {
      if (!authenticationCreate) {
        throw new Error(
          'Parameter `authenticationCreate` is required when calling `createAuthentication`.'
        );
      }

      if (!authenticationCreate.type) {
        throw new Error(
          'Parameter `authenticationCreate.type` is required when calling `createAuthentication`.'
        );
      }
      if (!authenticationCreate.name) {
        throw new Error(
          'Parameter `authenticationCreate.name` is required when calling `createAuthentication`.'
        );
      }
      if (!authenticationCreate.input) {
        throw new Error(
          'Parameter `authenticationCreate.input` is required when calling `createAuthentication`.'
        );
      }

      const requestPath = '/1/authentications';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: authenticationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new destination.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param destinationCreate -.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createDestination(
      destinationCreate: DestinationCreate,
      requestOptions?: RequestOptions
    ): Promise<DestinationCreateResponse> {
      if (!destinationCreate) {
        throw new Error(
          'Parameter `destinationCreate` is required when calling `createDestination`.'
        );
      }

      if (!destinationCreate.type) {
        throw new Error(
          'Parameter `destinationCreate.type` is required when calling `createDestination`.'
        );
      }
      if (!destinationCreate.name) {
        throw new Error(
          'Parameter `destinationCreate.name` is required when calling `createDestination`.'
        );
      }
      if (!destinationCreate.input) {
        throw new Error(
          'Parameter `destinationCreate.input` is required when calling `createDestination`.'
        );
      }

      const requestPath = '/1/destinations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: destinationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new source.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param sourceCreate -.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createSource(
      sourceCreate: SourceCreate,
      requestOptions?: RequestOptions
    ): Promise<SourceCreateResponse> {
      if (!sourceCreate) {
        throw new Error(
          'Parameter `sourceCreate` is required when calling `createSource`.'
        );
      }

      if (!sourceCreate.type) {
        throw new Error(
          'Parameter `sourceCreate.type` is required when calling `createSource`.'
        );
      }
      if (!sourceCreate.name) {
        throw new Error(
          'Parameter `sourceCreate.name` is required when calling `createSource`.'
        );
      }
      if (!sourceCreate.input) {
        throw new Error(
          'Parameter `sourceCreate.input` is required when calling `createSource`.'
        );
      }

      const requestPath = '/1/sources';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new task.
     *
     * @param taskCreate - Request body for creating a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createTask(
      taskCreate: TaskCreate,
      requestOptions?: RequestOptions
    ): Promise<TaskCreateResponse> {
      if (!taskCreate) {
        throw new Error(
          'Parameter `taskCreate` is required when calling `createTask`.'
        );
      }

      if (!taskCreate.sourceID) {
        throw new Error(
          'Parameter `taskCreate.sourceID` is required when calling `createTask`.'
        );
      }
      if (!taskCreate.destinationID) {
        throw new Error(
          'Parameter `taskCreate.destinationID` is required when calling `createTask`.'
        );
      }
      if (!taskCreate.trigger) {
        throw new Error(
          'Parameter `taskCreate.trigger` is required when calling `createTask`.'
        );
      }
      if (!taskCreate.action) {
        throw new Error(
          'Parameter `taskCreate.action` is required when calling `createTask`.'
        );
      }

      const requestPath = '/1/tasks';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: taskCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Creates a new transformation.
     *
     * @param transformationCreate - Request body for creating a transformation.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    createTransformation(
      transformationCreate: TransformationCreate,
      requestOptions?: RequestOptions
    ): Promise<TransformationCreateResponse> {
      if (!transformationCreate) {
        throw new Error(
          'Parameter `transformationCreate` is required when calling `createTransformation`.'
        );
      }

      if (!transformationCreate.code) {
        throw new Error(
          'Parameter `transformationCreate.code` is required when calling `createTransformation`.'
        );
      }
      if (!transformationCreate.name) {
        throw new Error(
          'Parameter `transformationCreate.name` is required when calling `createTransformation`.'
        );
      }
      if (!transformationCreate.description) {
        throw new Error(
          'Parameter `transformationCreate.description` is required when calling `createTransformation`.'
        );
      }

      const requestPath = '/1/transformations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param customDelete - The customDelete object.
     * @param customDelete.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customDelete.parameters - Query parameters to apply to the current query.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customDelete(
      { path, parameters }: CustomDeleteProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error(
          'Parameter `path` is required when calling `customDelete`.'
        );
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param customGet - The customGet object.
     * @param customGet.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customGet.parameters - Query parameters to apply to the current query.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customGet(
      { path, parameters }: CustomGetProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error(
          'Parameter `path` is required when calling `customGet`.'
        );
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param customPost - The customPost object.
     * @param customPost.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customPost.parameters - Query parameters to apply to the current query.
     * @param customPost.body - Parameters to send with the custom request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customPost(
      { path, parameters, body }: CustomPostProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error(
          'Parameter `path` is required when calling `customPost`.'
        );
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param customPut - The customPut object.
     * @param customPut.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param customPut.parameters - Query parameters to apply to the current query.
     * @param customPut.body - Parameters to send with the custom request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    customPut(
      { path, parameters, body }: CustomPutProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error(
          'Parameter `path` is required when calling `customPut`.'
        );
      }

      const requestPath = '/{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes an authentication resource. You can\'t delete authentication resources that are used by a source or a destination.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param deleteAuthentication - The deleteAuthentication object.
     * @param deleteAuthentication.authenticationID - Unique identifier of an authentication resource.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteAuthentication(
      { authenticationID }: DeleteAuthenticationProps,
      requestOptions?: RequestOptions
    ): Promise<DeleteResponse> {
      if (!authenticationID) {
        throw new Error(
          'Parameter `authenticationID` is required when calling `deleteAuthentication`.'
        );
      }

      const requestPath = '/1/authentications/{authenticationID}'.replace(
        '{authenticationID}',
        encodeURIComponent(authenticationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a destination by its ID. You can\'t delete destinations that are referenced in tasks.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param deleteDestination - The deleteDestination object.
     * @param deleteDestination.destinationID - Unique identifier of a destination.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteDestination(
      { destinationID }: DeleteDestinationProps,
      requestOptions?: RequestOptions
    ): Promise<DeleteResponse> {
      if (!destinationID) {
        throw new Error(
          'Parameter `destinationID` is required when calling `deleteDestination`.'
        );
      }

      const requestPath = '/1/destinations/{destinationID}'.replace(
        '{destinationID}',
        encodeURIComponent(destinationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a source by its ID. You can\'t delete sources that are referenced in tasks.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param deleteSource - The deleteSource object.
     * @param deleteSource.sourceID - Unique identifier of a source.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteSource(
      { sourceID }: DeleteSourceProps,
      requestOptions?: RequestOptions
    ): Promise<DeleteResponse> {
      if (!sourceID) {
        throw new Error(
          'Parameter `sourceID` is required when calling `deleteSource`.'
        );
      }

      const requestPath = '/1/sources/{sourceID}'.replace(
        '{sourceID}',
        encodeURIComponent(sourceID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a task by its ID.
     *
     * @param deleteTask - The deleteTask object.
     * @param deleteTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteTask(
      { taskID }: DeleteTaskProps,
      requestOptions?: RequestOptions
    ): Promise<DeleteResponse> {
      if (!taskID) {
        throw new Error(
          'Parameter `taskID` is required when calling `deleteTask`.'
        );
      }

      const requestPath = '/1/tasks/{taskID}'.replace(
        '{taskID}',
        encodeURIComponent(taskID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Deletes a transformation by its ID.
     *
     * @param deleteTransformation - The deleteTransformation object.
     * @param deleteTransformation.transformationID - Unique identifier of a transformation.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteTransformation(
      { transformationID }: DeleteTransformationProps,
      requestOptions?: RequestOptions
    ): Promise<DeleteResponse> {
      if (!transformationID) {
        throw new Error(
          'Parameter `transformationID` is required when calling `deleteTransformation`.'
        );
      }

      const requestPath = '/1/transformations/{transformationID}'.replace(
        '{transformationID}',
        encodeURIComponent(transformationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Disables a task.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param disableTask - The disableTask object.
     * @param disableTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    disableTask(
      { taskID }: DisableTaskProps,
      requestOptions?: RequestOptions
    ): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error(
          'Parameter `taskID` is required when calling `disableTask`.'
        );
      }

      const requestPath = '/1/tasks/{taskID}/disable'.replace(
        '{taskID}',
        encodeURIComponent(taskID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Enables a task.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param enableTask - The enableTask object.
     * @param enableTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    enableTask(
      { taskID }: EnableTaskProps,
      requestOptions?: RequestOptions
    ): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error(
          'Parameter `taskID` is required when calling `enableTask`.'
        );
      }

      const requestPath = '/1/tasks/{taskID}/enable'.replace(
        '{taskID}',
        encodeURIComponent(taskID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves an authentication resource by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getAuthentication - The getAuthentication object.
     * @param getAuthentication.authenticationID - Unique identifier of an authentication resource.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getAuthentication(
      { authenticationID }: GetAuthenticationProps,
      requestOptions?: RequestOptions
    ): Promise<Authentication> {
      if (!authenticationID) {
        throw new Error(
          'Parameter `authenticationID` is required when calling `getAuthentication`.'
        );
      }

      const requestPath = '/1/authentications/{authenticationID}'.replace(
        '{authenticationID}',
        encodeURIComponent(authenticationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of all authentication resources.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getAuthentications - The getAuthentications object.
     * @param getAuthentications.itemsPerPage - Number of items per page.
     * @param getAuthentications.page - Page number of the paginated API response.
     * @param getAuthentications.type - Type of authentication resource to retrieve.
     * @param getAuthentications.platform - Ecommerce platform for which to retrieve authentication resources.
     * @param getAuthentications.sort - Property by which to sort the list of authentication resources.
     * @param getAuthentications.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getAuthentications(
      {
        itemsPerPage,
        page,
        type,
        platform,
        sort,
        order,
      }: GetAuthenticationsProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<ListAuthenticationsResponse> {
      const requestPath = '/1/authentications';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters.itemsPerPage = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (type !== undefined) {
        queryParameters.type = type.toString();
      }

      if (platform !== undefined) {
        queryParameters.platform = platform.toString();
      }

      if (sort !== undefined) {
        queryParameters.sort = sort.toString();
      }

      if (order !== undefined) {
        queryParameters.order = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a destination by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getDestination - The getDestination object.
     * @param getDestination.destinationID - Unique identifier of a destination.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getDestination(
      { destinationID }: GetDestinationProps,
      requestOptions?: RequestOptions
    ): Promise<Destination> {
      if (!destinationID) {
        throw new Error(
          'Parameter `destinationID` is required when calling `getDestination`.'
        );
      }

      const requestPath = '/1/destinations/{destinationID}'.replace(
        '{destinationID}',
        encodeURIComponent(destinationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of destinations.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getDestinations - The getDestinations object.
     * @param getDestinations.itemsPerPage - Number of items per page.
     * @param getDestinations.page - Page number of the paginated API response.
     * @param getDestinations.type - Destination type.
     * @param getDestinations.authenticationID - Authentication ID used by destinations.
     * @param getDestinations.sort - Property by which to sort the destinations.
     * @param getDestinations.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getDestinations(
      {
        itemsPerPage,
        page,
        type,
        authenticationID,
        sort,
        order,
      }: GetDestinationsProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<ListDestinationsResponse> {
      const requestPath = '/1/destinations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters.itemsPerPage = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (type !== undefined) {
        queryParameters.type = type.toString();
      }

      if (authenticationID !== undefined) {
        queryParameters.authenticationID = authenticationID.toString();
      }

      if (sort !== undefined) {
        queryParameters.sort = sort.toString();
      }

      if (order !== undefined) {
        queryParameters.order = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a single task run event by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getEvent - The getEvent object.
     * @param getEvent.runID - Unique identifier of a task run.
     * @param getEvent.eventID - Unique identifier of an event.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getEvent(
      { runID, eventID }: GetEventProps,
      requestOptions?: RequestOptions
    ): Promise<Event> {
      if (!runID) {
        throw new Error(
          'Parameter `runID` is required when calling `getEvent`.'
        );
      }

      if (!eventID) {
        throw new Error(
          'Parameter `eventID` is required when calling `getEvent`.'
        );
      }

      const requestPath = '/1/runs/{runID}/events/{eventID}'
        .replace('{runID}', encodeURIComponent(runID))
        .replace('{eventID}', encodeURIComponent(eventID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of events for a task run, identified by it\'s ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getEvents - The getEvents object.
     * @param getEvents.runID - Unique identifier of a task run.
     * @param getEvents.itemsPerPage - Number of items per page.
     * @param getEvents.page - Page number of the paginated API response.
     * @param getEvents.status - Event status for filtering the list of task runs.
     * @param getEvents.type - Event type for filtering the list of task runs.
     * @param getEvents.sort - Property by which to sort the list of task run events.
     * @param getEvents.order - Sort order of the response, ascending or descending.
     * @param getEvents.startDate - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
     * @param getEvents.endDate - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getEvents(
      {
        runID,
        itemsPerPage,
        page,
        status,
        type,
        sort,
        order,
        startDate,
        endDate,
      }: GetEventsProps,
      requestOptions?: RequestOptions
    ): Promise<ListEventsResponse> {
      if (!runID) {
        throw new Error(
          'Parameter `runID` is required when calling `getEvents`.'
        );
      }

      const requestPath = '/1/runs/{runID}/events'.replace(
        '{runID}',
        encodeURIComponent(runID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters.itemsPerPage = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (status !== undefined) {
        queryParameters.status = status.toString();
      }

      if (type !== undefined) {
        queryParameters.type = type.toString();
      }

      if (sort !== undefined) {
        queryParameters.sort = sort.toString();
      }

      if (order !== undefined) {
        queryParameters.order = order.toString();
      }

      if (startDate !== undefined) {
        queryParameters.startDate = startDate.toString();
      }

      if (endDate !== undefined) {
        queryParameters.endDate = endDate.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve a single task run by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getRun - The getRun object.
     * @param getRun.runID - Unique identifier of a task run.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getRun(
      { runID }: GetRunProps,
      requestOptions?: RequestOptions
    ): Promise<Run> {
      if (!runID) {
        throw new Error('Parameter `runID` is required when calling `getRun`.');
      }

      const requestPath = '/1/runs/{runID}'.replace(
        '{runID}',
        encodeURIComponent(runID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve a list of task runs.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getRuns - The getRuns object.
     * @param getRuns.itemsPerPage - Number of items per page.
     * @param getRuns.page - Page number of the paginated API response.
     * @param getRuns.status - Run status for filtering the list of task runs.
     * @param getRuns.taskID - Task ID for filtering the list of task runs.
     * @param getRuns.sort - Property by which to sort the list of task runs.
     * @param getRuns.order - Sort order of the response, ascending or descending.
     * @param getRuns.startDate - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
     * @param getRuns.endDate - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getRuns(
      {
        itemsPerPage,
        page,
        status,
        taskID,
        sort,
        order,
        startDate,
        endDate,
      }: GetRunsProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<RunListResponse> {
      const requestPath = '/1/runs';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters.itemsPerPage = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (status !== undefined) {
        queryParameters.status = status.toString();
      }

      if (taskID !== undefined) {
        queryParameters.taskID = taskID.toString();
      }

      if (sort !== undefined) {
        queryParameters.sort = sort.toString();
      }

      if (order !== undefined) {
        queryParameters.order = order.toString();
      }

      if (startDate !== undefined) {
        queryParameters.startDate = startDate.toString();
      }

      if (endDate !== undefined) {
        queryParameters.endDate = endDate.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve a source by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getSource - The getSource object.
     * @param getSource.sourceID - Unique identifier of a source.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getSource(
      { sourceID }: GetSourceProps,
      requestOptions?: RequestOptions
    ): Promise<Source> {
      if (!sourceID) {
        throw new Error(
          'Parameter `sourceID` is required when calling `getSource`.'
        );
      }

      const requestPath = '/1/sources/{sourceID}'.replace(
        '{sourceID}',
        encodeURIComponent(sourceID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of sources.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getSources - The getSources object.
     * @param getSources.itemsPerPage - Number of items per page.
     * @param getSources.page - Page number of the paginated API response.
     * @param getSources.type - Source type. Some sources require authentication.
     * @param getSources.authenticationID - Authentication IDs of the sources to retrieve. \'none\' returns sources that doesn\'t have an authentication resource.
     * @param getSources.sort - Property by which to sort the list of sources.
     * @param getSources.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getSources(
      {
        itemsPerPage,
        page,
        type,
        authenticationID,
        sort,
        order,
      }: GetSourcesProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<ListSourcesResponse> {
      const requestPath = '/1/sources';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters.itemsPerPage = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (type !== undefined) {
        queryParameters.type = type.toString();
      }

      if (authenticationID !== undefined) {
        queryParameters.authenticationID = authenticationID.toString();
      }

      if (sort !== undefined) {
        queryParameters.sort = sort.toString();
      }

      if (order !== undefined) {
        queryParameters.order = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a task by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getTask - The getTask object.
     * @param getTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTask(
      { taskID }: GetTaskProps,
      requestOptions?: RequestOptions
    ): Promise<Task> {
      if (!taskID) {
        throw new Error(
          'Parameter `taskID` is required when calling `getTask`.'
        );
      }

      const requestPath = '/1/tasks/{taskID}'.replace(
        '{taskID}',
        encodeURIComponent(taskID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of tasks.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getTasks - The getTasks object.
     * @param getTasks.itemsPerPage - Number of items per page.
     * @param getTasks.page - Page number of the paginated API response.
     * @param getTasks.action - Actions for filtering the list of tasks.
     * @param getTasks.enabled - Whether to filter the list of tasks by the `enabled` status.
     * @param getTasks.sourceID - Source IDs for filtering the list of tasks.
     * @param getTasks.destinationID - Destination IDs for filtering the list of tasks.
     * @param getTasks.triggerType - Type of task trigger for filtering the list of tasks.
     * @param getTasks.sort - Property by which to sort the list of tasks.
     * @param getTasks.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTasks(
      {
        itemsPerPage,
        page,
        action,
        enabled,
        sourceID,
        destinationID,
        triggerType,
        sort,
        order,
      }: GetTasksProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<ListTasksResponse> {
      const requestPath = '/1/tasks';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (itemsPerPage !== undefined) {
        queryParameters.itemsPerPage = itemsPerPage.toString();
      }

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (action !== undefined) {
        queryParameters.action = action.toString();
      }

      if (enabled !== undefined) {
        queryParameters.enabled = enabled.toString();
      }

      if (sourceID !== undefined) {
        queryParameters.sourceID = sourceID.toString();
      }

      if (destinationID !== undefined) {
        queryParameters.destinationID = destinationID.toString();
      }

      if (triggerType !== undefined) {
        queryParameters.triggerType = triggerType.toString();
      }

      if (sort !== undefined) {
        queryParameters.sort = sort.toString();
      }

      if (order !== undefined) {
        queryParameters.order = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a transformation by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getTransformation - The getTransformation object.
     * @param getTransformation.transformationID - Unique identifier of a transformation.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTransformation(
      { transformationID }: GetTransformationProps,
      requestOptions?: RequestOptions
    ): Promise<Transformation> {
      if (!transformationID) {
        throw new Error(
          'Parameter `transformationID` is required when calling `getTransformation`.'
        );
      }

      const requestPath = '/1/transformations/{transformationID}'.replace(
        '{transformationID}',
        encodeURIComponent(transformationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieves a list of transformations.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param getTransformations - The getTransformations object.
     * @param getTransformations.sort - Property by which to sort the list.
     * @param getTransformations.order - Sort order of the response, ascending or descending.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTransformations(
      { sort, order }: GetTransformationsProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<ListTransformationsResponse> {
      const requestPath = '/1/transformations';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (sort !== undefined) {
        queryParameters.sort = sort.toString();
      }

      if (order !== undefined) {
        queryParameters.order = order.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Runs a task. You can check the status of task runs with the observability endpoints.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param runTask - The runTask object.
     * @param runTask.taskID - Unique identifier of a task.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    runTask(
      { taskID }: RunTaskProps,
      requestOptions?: RequestOptions
    ): Promise<RunResponse> {
      if (!taskID) {
        throw new Error(
          'Parameter `taskID` is required when calling `runTask`.'
        );
      }

      const requestPath = '/1/tasks/{taskID}/run'.replace(
        '{taskID}',
        encodeURIComponent(taskID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for authentication resources.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param authenticationSearch - The authenticationSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchAuthentications(
      authenticationSearch: AuthenticationSearch,
      requestOptions?: RequestOptions
    ): Promise<Authentication[]> {
      if (!authenticationSearch) {
        throw new Error(
          'Parameter `authenticationSearch` is required when calling `searchAuthentications`.'
        );
      }

      if (!authenticationSearch.authenticationIDs) {
        throw new Error(
          'Parameter `authenticationSearch.authenticationIDs` is required when calling `searchAuthentications`.'
        );
      }

      const requestPath = '/1/authentications/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: authenticationSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for destinations.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param destinationSearch - The destinationSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchDestinations(
      destinationSearch: DestinationSearch,
      requestOptions?: RequestOptions
    ): Promise<Destination[]> {
      if (!destinationSearch) {
        throw new Error(
          'Parameter `destinationSearch` is required when calling `searchDestinations`.'
        );
      }

      if (!destinationSearch.destinationIDs) {
        throw new Error(
          'Parameter `destinationSearch.destinationIDs` is required when calling `searchDestinations`.'
        );
      }

      const requestPath = '/1/destinations/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: destinationSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for sources.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param sourceSearch - The sourceSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchSources(
      sourceSearch: SourceSearch,
      requestOptions?: RequestOptions
    ): Promise<Source[]> {
      if (!sourceSearch) {
        throw new Error(
          'Parameter `sourceSearch` is required when calling `searchSources`.'
        );
      }

      if (!sourceSearch.sourceIDs) {
        throw new Error(
          'Parameter `sourceSearch.sourceIDs` is required when calling `searchSources`.'
        );
      }

      const requestPath = '/1/sources/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for tasks.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param taskSearch - The taskSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchTasks(
      taskSearch: TaskSearch,
      requestOptions?: RequestOptions
    ): Promise<Task[]> {
      if (!taskSearch) {
        throw new Error(
          'Parameter `taskSearch` is required when calling `searchTasks`.'
        );
      }

      if (!taskSearch.taskIDs) {
        throw new Error(
          'Parameter `taskSearch.taskIDs` is required when calling `searchTasks`.'
        );
      }

      const requestPath = '/1/tasks/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: taskSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Searches for transformations.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param transformationSearch - The transformationSearch object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchTransformations(
      transformationSearch: TransformationSearch,
      requestOptions?: RequestOptions
    ): Promise<Transformation[]> {
      if (!transformationSearch) {
        throw new Error(
          'Parameter `transformationSearch` is required when calling `searchTransformations`.'
        );
      }

      if (!transformationSearch.transformationsIDs) {
        throw new Error(
          'Parameter `transformationSearch.transformationsIDs` is required when calling `searchTransformations`.'
        );
      }

      const requestPath = '/1/transformations/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationSearch,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Triggers a stream-listing request for a source. Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param triggerDockerSourceDiscover - The triggerDockerSourceDiscover object.
     * @param triggerDockerSourceDiscover.sourceID - Unique identifier of a source.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    triggerDockerSourceDiscover(
      { sourceID }: TriggerDockerSourceDiscoverProps,
      requestOptions?: RequestOptions
    ): Promise<SourceWatchResponse> {
      if (!sourceID) {
        throw new Error(
          'Parameter `sourceID` is required when calling `triggerDockerSourceDiscover`.'
        );
      }

      const requestPath = '/1/sources/{sourceID}/discover'.replace(
        '{sourceID}',
        encodeURIComponent(sourceID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Try a transformation.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param transformationTry - The transformationTry object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    tryTransformations(
      transformationTry: TransformationTry,
      requestOptions?: RequestOptions
    ): Promise<TransformationTryResponse> {
      if (!transformationTry) {
        throw new Error(
          'Parameter `transformationTry` is required when calling `tryTransformations`.'
        );
      }

      if (!transformationTry.code) {
        throw new Error(
          'Parameter `transformationTry.code` is required when calling `tryTransformations`.'
        );
      }
      if (!transformationTry.sampleRecord) {
        throw new Error(
          'Parameter `transformationTry.sampleRecord` is required when calling `tryTransformations`.'
        );
      }

      const requestPath = '/1/transformations/try';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationTry,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates an authentication resource.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param updateAuthentication - The updateAuthentication object.
     * @param updateAuthentication.authenticationID - Unique identifier of an authentication resource.
     * @param updateAuthentication.authenticationUpdate - The authenticationUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateAuthentication(
      { authenticationID, authenticationUpdate }: UpdateAuthenticationProps,
      requestOptions?: RequestOptions
    ): Promise<AuthenticationUpdateResponse> {
      if (!authenticationID) {
        throw new Error(
          'Parameter `authenticationID` is required when calling `updateAuthentication`.'
        );
      }

      if (!authenticationUpdate) {
        throw new Error(
          'Parameter `authenticationUpdate` is required when calling `updateAuthentication`.'
        );
      }

      const requestPath = '/1/authentications/{authenticationID}'.replace(
        '{authenticationID}',
        encodeURIComponent(authenticationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: authenticationUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates the destination by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param updateDestination - The updateDestination object.
     * @param updateDestination.destinationID - Unique identifier of a destination.
     * @param updateDestination.destinationUpdate - The destinationUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateDestination(
      { destinationID, destinationUpdate }: UpdateDestinationProps,
      requestOptions?: RequestOptions
    ): Promise<DestinationUpdateResponse> {
      if (!destinationID) {
        throw new Error(
          'Parameter `destinationID` is required when calling `updateDestination`.'
        );
      }

      if (!destinationUpdate) {
        throw new Error(
          'Parameter `destinationUpdate` is required when calling `updateDestination`.'
        );
      }

      const requestPath = '/1/destinations/{destinationID}'.replace(
        '{destinationID}',
        encodeURIComponent(destinationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: destinationUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates a source by its ID.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param updateSource - The updateSource object.
     * @param updateSource.sourceID - Unique identifier of a source.
     * @param updateSource.sourceUpdate - The sourceUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateSource(
      { sourceID, sourceUpdate }: UpdateSourceProps,
      requestOptions?: RequestOptions
    ): Promise<SourceUpdateResponse> {
      if (!sourceID) {
        throw new Error(
          'Parameter `sourceID` is required when calling `updateSource`.'
        );
      }

      if (!sourceUpdate) {
        throw new Error(
          'Parameter `sourceUpdate` is required when calling `updateSource`.'
        );
      }

      const requestPath = '/1/sources/{sourceID}'.replace(
        '{sourceID}',
        encodeURIComponent(sourceID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates a task by its ID.
     *
     * @param updateTask - The updateTask object.
     * @param updateTask.taskID - Unique identifier of a task.
     * @param updateTask.taskUpdate - The taskUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateTask(
      { taskID, taskUpdate }: UpdateTaskProps,
      requestOptions?: RequestOptions
    ): Promise<TaskUpdateResponse> {
      if (!taskID) {
        throw new Error(
          'Parameter `taskID` is required when calling `updateTask`.'
        );
      }

      if (!taskUpdate) {
        throw new Error(
          'Parameter `taskUpdate` is required when calling `updateTask`.'
        );
      }

      const requestPath = '/1/tasks/{taskID}'.replace(
        '{taskID}',
        encodeURIComponent(taskID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PATCH',
        path: requestPath,
        queryParameters,
        headers,
        data: taskUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Updates a transformation by its ID.
     *
     * @param updateTransformation - The updateTransformation object.
     * @param updateTransformation.transformationID - Unique identifier of a transformation.
     * @param updateTransformation.transformationCreate - The transformationCreate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateTransformation(
      { transformationID, transformationCreate }: UpdateTransformationProps,
      requestOptions?: RequestOptions
    ): Promise<TransformationUpdateResponse> {
      if (!transformationID) {
        throw new Error(
          'Parameter `transformationID` is required when calling `updateTransformation`.'
        );
      }

      if (!transformationCreate) {
        throw new Error(
          'Parameter `transformationCreate` is required when calling `updateTransformation`.'
        );
      }

      if (!transformationCreate.code) {
        throw new Error(
          'Parameter `transformationCreate.code` is required when calling `updateTransformation`.'
        );
      }
      if (!transformationCreate.name) {
        throw new Error(
          'Parameter `transformationCreate.name` is required when calling `updateTransformation`.'
        );
      }
      if (!transformationCreate.description) {
        throw new Error(
          'Parameter `transformationCreate.description` is required when calling `updateTransformation`.'
        );
      }

      const requestPath = '/1/transformations/{transformationID}'.replace(
        '{transformationID}',
        encodeURIComponent(transformationID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: transformationCreate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param sourceCreate -.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    validateSource(
      sourceCreate: SourceCreate,
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<SourceWatchResponse> {
      const requestPath = '/1/sources/validate';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceCreate ? sourceCreate : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.
     *
     * Required API Key ACLs:
     * - addObject
     * - deleteIndex
     * - editSettings.
     *
     * @param validateSourceBeforeUpdate - The validateSourceBeforeUpdate object.
     * @param validateSourceBeforeUpdate.sourceID - Unique identifier of a source.
     * @param validateSourceBeforeUpdate.sourceUpdate - The sourceUpdate object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    validateSourceBeforeUpdate(
      { sourceID, sourceUpdate }: ValidateSourceBeforeUpdateProps,
      requestOptions?: RequestOptions
    ): Promise<SourceWatchResponse> {
      if (!sourceID) {
        throw new Error(
          'Parameter `sourceID` is required when calling `validateSourceBeforeUpdate`.'
        );
      }

      if (!sourceUpdate) {
        throw new Error(
          'Parameter `sourceUpdate` is required when calling `validateSourceBeforeUpdate`.'
        );
      }

      const requestPath = '/1/sources/{sourceID}/validate'.replace(
        '{sourceID}',
        encodeURIComponent(sourceID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: sourceUpdate,
      };

      return transporter.request(request, requestOptions);
    },
  };
}
