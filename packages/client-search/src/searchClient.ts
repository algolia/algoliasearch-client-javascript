// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import {
  createAuth,
  createTransporter,
  getAlgoliaAgent,
  shuffle,
  createIterablePromise,
} from '@algolia/client-common';
import type {
  CreateClientOptions,
  Headers,
  Host,
  Request,
  RequestOptions,
  QueryParameters,
  ApiError,
  IterableOptions,
} from '@algolia/client-common';

import type { AddApiKeyResponse } from '../model/addApiKeyResponse';
import type { ApiKey } from '../model/apiKey';
import type { BatchParams } from '../model/batchParams';
import type { BatchResponse } from '../model/batchResponse';
import type { BrowseResponse } from '../model/browseResponse';
import type {
  BrowseOptions,
  WaitForTaskOptions,
  WaitForApiKeyOptions,
  AddOrUpdateObjectProps,
  AssignUserIdProps,
  BatchProps,
  BatchAssignUserIdsProps,
  BatchDictionaryEntriesProps,
  BrowseProps,
  ClearAllSynonymsProps,
  ClearObjectsProps,
  ClearRulesProps,
  DelProps,
  DeleteApiKeyProps,
  DeleteByProps,
  DeleteIndexProps,
  DeleteObjectProps,
  DeleteRuleProps,
  DeleteSourceProps,
  DeleteSynonymProps,
  GetProps,
  GetApiKeyProps,
  GetLogsProps,
  GetObjectProps,
  GetRuleProps,
  GetSettingsProps,
  GetSynonymProps,
  GetTaskProps,
  GetUserIdProps,
  HasPendingMappingsProps,
  ListIndicesProps,
  ListUserIdsProps,
  OperationIndexProps,
  PartialUpdateObjectProps,
  PostProps,
  PutProps,
  RemoveUserIdProps,
  ReplaceSourcesProps,
  RestoreApiKeyProps,
  SaveObjectProps,
  SaveRuleProps,
  SaveRulesProps,
  SaveSynonymProps,
  SaveSynonymsProps,
  LegacySearchMethodProps,
  SearchDictionaryEntriesProps,
  SearchForFacetValuesProps,
  SearchRulesProps,
  SearchSingleIndexProps,
  SearchSynonymsProps,
  SetSettingsProps,
  UpdateApiKeyProps,
} from '../model/clientMethodProps';
import type { CreatedAtResponse } from '../model/createdAtResponse';
import type { DeleteApiKeyResponse } from '../model/deleteApiKeyResponse';
import type { DeleteSourceResponse } from '../model/deleteSourceResponse';
import type { DeletedAtResponse } from '../model/deletedAtResponse';
import type { DictionarySettingsParams } from '../model/dictionarySettingsParams';
import type { GetApiKeyResponse } from '../model/getApiKeyResponse';
import type { GetDictionarySettingsResponse } from '../model/getDictionarySettingsResponse';
import type { GetLogsResponse } from '../model/getLogsResponse';
import type { GetObjectsParams } from '../model/getObjectsParams';
import type { GetObjectsResponse } from '../model/getObjectsResponse';
import type { GetTaskResponse } from '../model/getTaskResponse';
import type { GetTopUserIdsResponse } from '../model/getTopUserIdsResponse';
import type { HasPendingMappingsResponse } from '../model/hasPendingMappingsResponse';
import type { IndexSettings } from '../model/indexSettings';
import type { Languages } from '../model/languages';
import type { ListApiKeysResponse } from '../model/listApiKeysResponse';
import type { ListClustersResponse } from '../model/listClustersResponse';
import type { ListIndicesResponse } from '../model/listIndicesResponse';
import type { ListUserIdsResponse } from '../model/listUserIdsResponse';
import type { MultipleBatchResponse } from '../model/multipleBatchResponse';
import type { RemoveUserIdResponse } from '../model/removeUserIdResponse';
import type { ReplaceSourceResponse } from '../model/replaceSourceResponse';
import type { Rule } from '../model/rule';
import type { SaveObjectResponse } from '../model/saveObjectResponse';
import type { SaveSynonymResponse } from '../model/saveSynonymResponse';
import type { SearchForFacetValuesResponse } from '../model/searchForFacetValuesResponse';
import type { SearchMethodParams } from '../model/searchMethodParams';
import type { SearchResponse } from '../model/searchResponse';
import type { SearchResponses } from '../model/searchResponses';
import type { SearchRulesResponse } from '../model/searchRulesResponse';
import type { SearchSynonymsResponse } from '../model/searchSynonymsResponse';
import type { SearchUserIdsParams } from '../model/searchUserIdsParams';
import type { SearchUserIdsResponse } from '../model/searchUserIdsResponse';
import type { Source } from '../model/source';
import type { SynonymHit } from '../model/synonymHit';
import type { UpdateApiKeyResponse } from '../model/updateApiKeyResponse';
import type { UpdatedAtResponse } from '../model/updatedAtResponse';
import type { UpdatedAtWithObjectIdResponse } from '../model/updatedAtWithObjectIdResponse';
import type { UpdatedRuleResponse } from '../model/updatedRuleResponse';
import type { UserId } from '../model/userId';

export const apiClientVersion = '5.0.0-alpha.89';

function getDefaultHosts(appId: string): Host[] {
  return (
    [
      {
        url: `${appId}-dsn.algolia.net`,
        accept: 'read',
        protocol: 'https',
      },
      {
        url: `${appId}.algolia.net`,
        accept: 'write',
        protocol: 'https',
      },
    ] as Host[]
  ).concat(
    shuffle([
      {
        url: `${appId}-1.algolianet.com`,
        accept: 'readWrite',
        protocol: 'https',
      },
      {
        url: `${appId}-2.algolianet.com`,
        accept: 'readWrite',
        protocol: 'https',
      },
      {
        url: `${appId}-3.algolianet.com`,
        accept: 'readWrite',
        protocol: 'https',
      },
    ])
  );
}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function createSearchClient({
  appId: appIdOption,
  apiKey: apiKeyOption,
  authMode,
  algoliaAgents,
  ...options
}: CreateClientOptions) {
  const auth = createAuth(appIdOption, apiKeyOption, authMode);
  const transporter = createTransporter({
    hosts: getDefaultHosts(appIdOption),
    ...options,
    algoliaAgent: getAlgoliaAgent({
      algoliaAgents,
      client: 'Search',
      version: apiClientVersion,
    }),
    baseHeaders: {
      'content-type': 'text/plain',
      ...auth.headers(),
      ...options.baseHeaders,
    },
    baseQueryParameters: {
      ...auth.queryParameters(),
      ...options.baseQueryParameters,
    },
  });

  return {
    transporter,

    /**
     * The `appId` currently in use.
     */
    appId: appIdOption,

    /**
     * Clears the cache of the transporter for the `requestsCache` and `responsesCache` properties.
     */
    clearCache(): Promise<void> {
      return Promise.all([
        transporter.requestsCache.clear(),
        transporter.responsesCache.clear(),
      ]).then(() => undefined);
    },

    /**
     * Get the value of the `algoliaAgent`, used by our libraries internally and telemetry system.
     */
    get _ua(): string {
      return transporter.algoliaAgent.value;
    },

    /**
     * Adds a `segment` to the `x-algolia-agent` sent with every requests.
     *
     * @param segment - The algolia agent (user-agent) segment to add.
     * @param version - The version of the agent.
     */
    addAlgoliaAgent(segment: string, version?: string): void {
      transporter.algoliaAgent.add({ segment, version });
    },

    /**
     * Helper: Wait for a task to be published (completed) for a given `indexName` and `taskID`.
     *
     * @summary Helper method that waits for a task to be published (completed).
     * @param waitForTaskOptions - The waitForTaskOptions object.
     * @param waitForTaskOptions.indexName - The `indexName` where the operation was performed.
     * @param waitForTaskOptions.taskID - The `taskID` returned in the method response.
     * @param waitForTaskOptions.maxRetries - The maximum number of retries. 50 by default.
     * @param waitForTaskOptions.timeout - The function to decide how long to wait between retries.
     * @param requestOptions - The requestOptions to send along with the query, they will be forwarded to the `getTask` method and merged with the transporter requestOptions.
     */
    waitForTask(
      {
        indexName,
        taskID,
        maxRetries = 50,
        timeout = (retryCount: number): number =>
          Math.min(retryCount * 200, 5000),
      }: WaitForTaskOptions,
      requestOptions?: RequestOptions
    ): Promise<GetTaskResponse> {
      let retryCount = 0;

      return createIterablePromise({
        func: () => this.getTask({ indexName, taskID }, requestOptions),
        validate: (response) => response.status === 'published',
        aggregator: () => (retryCount += 1),
        error: {
          validate: () => retryCount >= maxRetries,
          message: () =>
            `The maximum number of retries exceeded. (${retryCount}/${maxRetries})`,
        },
        timeout: () => timeout(retryCount),
      });
    },

    /**
     * Helper: Wait for an API key to be added, updated or deleted based on a given `operation`.
     *
     * @summary Helper method that waits for an API key task to be processed.
     * @param waitForApiKeyOptions - The waitForApiKeyOptions object.
     * @param waitForApiKeyOptions.operation - The `operation` that was done on a `key`.
     * @param waitForApiKeyOptions.key - The `key` that has been added, deleted or updated.
     * @param waitForApiKeyOptions.apiKey - Necessary to know if an `update` operation has been processed, compare fields of the response with it.
     * @param waitForApiKeyOptions.maxRetries - The maximum number of retries. 50 by default.
     * @param waitForApiKeyOptions.timeout - The function to decide how long to wait between retries.
     * @param requestOptions - The requestOptions to send along with the query, they will be forwarded to the `getApikey` method and merged with the transporter requestOptions.
     */
    waitForApiKey(
      {
        operation,
        key,
        apiKey,
        maxRetries = 50,
        timeout = (retryCount: number): number =>
          Math.min(retryCount * 200, 5000),
      }: WaitForApiKeyOptions,
      requestOptions?: RequestOptions
    ): Promise<ApiError | GetApiKeyResponse> {
      let retryCount = 0;
      const baseIteratorOptions: IterableOptions<ApiError | GetApiKeyResponse> =
        {
          aggregator: () => (retryCount += 1),
          error: {
            validate: () => retryCount >= maxRetries,
            message: () =>
              `The maximum number of retries exceeded. (${retryCount}/${maxRetries})`,
          },
          timeout: () => timeout(retryCount),
        };

      if (operation === 'update') {
        if (!apiKey) {
          throw new Error(
            '`apiKey` is required when waiting for an `update` operation.'
          );
        }

        return createIterablePromise({
          ...baseIteratorOptions,
          func: () => this.getApiKey({ key }, requestOptions),
          validate: (response) => {
            for (const field of Object.keys(apiKey)) {
              const value = apiKey[field as keyof ApiKey];
              const resValue = response[field as keyof ApiKey];
              if (Array.isArray(value) && Array.isArray(resValue)) {
                if (
                  value.length !== resValue.length ||
                  value.some((v, index) => v !== resValue[index])
                ) {
                  return false;
                }
              } else if (value !== resValue) {
                return false;
              }
            }
            return true;
          },
        });
      }

      return createIterablePromise({
        ...baseIteratorOptions,
        func: () =>
          this.getApiKey({ key }, requestOptions).catch((error) => error),
        validate: (error: ApiError) =>
          operation === 'add' ? error.status !== 404 : error.status === 404,
      });
    },

    /**
     * Helper: Iterate on the `browse` method of the client to allow aggregating objects of an index.
     *
     * @summary Helper method that iterates on the `browse` method.
     * @param browseObjects - The browseObjects object.
     * @param browseObjects.indexName - The index in which to perform the request.
     * @param browseObjects.browseParams - The `browse` parameters.
     * @param browseObjects.validate - The validator function. It receive the resolved return of the API call. By default, stops when there is no `cursor` in the response.
     * @param browseObjects.aggregator - The function that runs right after the API call has been resolved, allows you to do anything with the response before `validate`.
     * @param requestOptions - The requestOptions to send along with the query, they will be forwarded to the `browse` method and merged with the transporter requestOptions.
     */
    browseObjects<T>(
      {
        indexName,
        browseParams,
        ...browseObjectsOptions
      }: BrowseOptions<BrowseResponse<T>> & BrowseProps,
      requestOptions?: RequestOptions
    ): Promise<BrowseResponse<T>> {
      return createIterablePromise<BrowseResponse<T>>({
        func: (previousResponse) => {
          return this.browse(
            {
              indexName,
              browseParams: {
                cursor: previousResponse ? previousResponse.cursor : undefined,
                ...browseParams,
              },
            },
            requestOptions
          );
        },
        validate: (response) => response.cursor === undefined,
        ...browseObjectsOptions,
      });
    },

    /**
     * Helper: Iterate on the `searchRules` method of the client to allow aggregating rules of an index.
     *
     * @summary Helper method that iterates on the `searchRules` method.
     * @param browseObjects - The browseObjects object.
     * @param browseObjects.indexName - The index in which to perform the request.
     * @param browseObjects.searchRulesParams - The `searchRules` method parameters.
     * @param browseObjects.validate - The validator function. It receive the resolved return of the API call. By default, stops when there is less hits returned than the number of maximum hits (1000).
     * @param browseObjects.aggregator - The function that runs right after the API call has been resolved, allows you to do anything with the response before `validate`.
     * @param requestOptions - The requestOptions to send along with the query, they will be forwarded to the `searchRules` method and merged with the transporter requestOptions.
     */
    browseRules(
      {
        indexName,
        searchRulesParams,
        ...browseRulesOptions
      }: BrowseOptions<SearchRulesResponse> & SearchRulesProps,
      requestOptions?: RequestOptions
    ): Promise<SearchRulesResponse> {
      const params = {
        hitsPerPage: 1000,
        ...searchRulesParams,
      };

      return createIterablePromise<SearchRulesResponse>({
        func: (previousResponse) => {
          return this.searchRules(
            {
              indexName,
              searchRulesParams: {
                ...params,
                page: previousResponse
                  ? previousResponse.page + 1
                  : params.page || 0,
              },
            },
            requestOptions
          );
        },
        validate: (response) => response.nbHits < params.hitsPerPage,
        ...browseRulesOptions,
      });
    },

    /**
     * Helper: Iterate on the `searchSynonyms` method of the client to allow aggregating rules of an index.
     *
     * @summary Helper method that iterates on the `searchSynonyms` method.
     * @param browseObjects - The browseObjects object.
     * @param browseObjects.indexName - The index in which to perform the request.
     * @param browseObjects.validate - The validator function. It receive the resolved return of the API call. By default, stops when there is less hits returned than the number of maximum hits (1000).
     * @param browseObjects.aggregator - The function that runs right after the API call has been resolved, allows you to do anything with the response before `validate`.
     * @param requestOptions - The requestOptions to send along with the query, they will be forwarded to the `searchSynonyms` method and merged with the transporter requestOptions.
     */
    browseSynonyms(
      {
        indexName,
        validate,
        aggregator,
        ...browseSynonymsOptions
      }: BrowseOptions<SearchSynonymsResponse> & SearchSynonymsProps,
      requestOptions?: RequestOptions
    ): Promise<SearchSynonymsResponse> {
      const params = {
        hitsPerPage: 1000,
        ...browseSynonymsOptions,
      };

      return createIterablePromise<SearchSynonymsResponse>({
        func: (previousResponse) => {
          return this.searchSynonyms(
            {
              ...params,
              indexName,
              page: previousResponse
                ? previousResponse.page + 1
                : browseSynonymsOptions.page || 0,
            },
            requestOptions
          );
        },
        validate: (response) => response.nbHits < params.hitsPerPage,
        ...browseSynonymsOptions,
      });
    },

    /**
     * Helper: calls the `search` method but with certainty that we will only request Algolia records (hits) and not facets.
     * Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent impacting search performances, this helper is purely for typing purposes.
     *
     * @summary Search multiple indices for `hits`.
     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchForHits<T>(
      searchMethodParams: LegacySearchMethodProps | SearchMethodParams,
      requestOptions?: RequestOptions
    ): Promise<{ results: Array<SearchResponse<T>> }> {
      return this.search(searchMethodParams, requestOptions) as Promise<{
        results: Array<SearchResponse<T>>;
      }>;
    },

    /**
     * Helper: calls the `search` method but with certainty that we will only request Algolia facets and not records (hits).
     * Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to prevent impacting search performances, this helper is purely for typing purposes.
     *
     * @summary Search multiple indices for `facets`.
     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchForFacets(
      searchMethodParams: LegacySearchMethodProps | SearchMethodParams,
      requestOptions?: RequestOptions
    ): Promise<{ results: SearchForFacetValuesResponse[] }> {
      return this.search(searchMethodParams, requestOptions) as Promise<{
        results: SearchForFacetValuesResponse[];
      }>;
    },
    /**
     * Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.
     *
     * @summary Add API key.
     * @param apiKey - The apiKey object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    addApiKey(
      apiKey: ApiKey,
      requestOptions?: RequestOptions
    ): Promise<AddApiKeyResponse> {
      if (!apiKey) {
        throw new Error(
          'Parameter `apiKey` is required when calling `addApiKey`.'
        );
      }

      if (!apiKey.acl) {
        throw new Error(
          'Parameter `apiKey.acl` is required when calling `addApiKey`.'
        );
      }

      const requestPath = '/1/keys';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: apiKey,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
     *
     * @summary Add or update a record (using objectID).
     * @param addOrUpdateObject - The addOrUpdateObject object.
     * @param addOrUpdateObject.indexName - Index on which to perform the request.
     * @param addOrUpdateObject.objectID - Unique record (object) identifier.
     * @param addOrUpdateObject.body - Algolia record.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    addOrUpdateObject(
      { indexName, objectID, body }: AddOrUpdateObjectProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtWithObjectIdResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `addOrUpdateObject`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `addOrUpdateObject`.'
        );
      }

      if (!body) {
        throw new Error(
          'Parameter `body` is required when calling `addOrUpdateObject`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: body,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Add a source to the list of allowed sources.
     *
     * @summary Add a source.
     * @param source - Source to add.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    appendSource(
      source: Source,
      requestOptions?: RequestOptions
    ): Promise<CreatedAtResponse> {
      if (!source) {
        throw new Error(
          'Parameter `source` is required when calling `appendSource`.'
        );
      }

      if (!source.source) {
        throw new Error(
          'Parameter `source.source` is required when calling `appendSource`.'
        );
      }

      const requestPath = '/1/security/sources/append';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: source,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.
     *
     * @summary Assign or move a user ID.
     * @param assignUserId - The assignUserId object.
     * @param assignUserId.xAlgoliaUserID - UserID to assign.
     * @param assignUserId.assignUserIdParams - The assignUserIdParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    assignUserId(
      { xAlgoliaUserID, assignUserIdParams }: AssignUserIdProps,
      requestOptions?: RequestOptions
    ): Promise<CreatedAtResponse> {
      if (!xAlgoliaUserID) {
        throw new Error(
          'Parameter `xAlgoliaUserID` is required when calling `assignUserId`.'
        );
      }

      if (!assignUserIdParams) {
        throw new Error(
          'Parameter `assignUserIdParams` is required when calling `assignUserId`.'
        );
      }

      if (!assignUserIdParams.cluster) {
        throw new Error(
          'Parameter `assignUserIdParams.cluster` is required when calling `assignUserId`.'
        );
      }

      const requestPath = '/1/clusters/mapping';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (xAlgoliaUserID !== undefined) {
        headers['X-Algolia-User-ID'] = xAlgoliaUserID.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: assignUserIdParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual operations of the same name.
     *
     * @summary Batch write operations on one index.
     * @param batch - The batch object.
     * @param batch.indexName - Index on which to perform the request.
     * @param batch.batchWriteParams - The batchWriteParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    batch(
      { indexName, batchWriteParams }: BatchProps,
      requestOptions?: RequestOptions
    ): Promise<BatchResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `batch`.'
        );
      }

      if (!batchWriteParams) {
        throw new Error(
          'Parameter `batchWriteParams` is required when calling `batch`.'
        );
      }

      if (!batchWriteParams.requests) {
        throw new Error(
          'Parameter `batchWriteParams.requests` is required when calling `batch`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/batch'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: batchWriteParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Assign multiple user IDs to a cluster. **You can\'t _move_ users with this operation.**.
     *
     * @summary Batch assign userIDs.
     * @param batchAssignUserIds - The batchAssignUserIds object.
     * @param batchAssignUserIds.xAlgoliaUserID - UserID to assign.
     * @param batchAssignUserIds.batchAssignUserIdsParams - The batchAssignUserIdsParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    batchAssignUserIds(
      { xAlgoliaUserID, batchAssignUserIdsParams }: BatchAssignUserIdsProps,
      requestOptions?: RequestOptions
    ): Promise<CreatedAtResponse> {
      if (!xAlgoliaUserID) {
        throw new Error(
          'Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`.'
        );
      }

      if (!batchAssignUserIdsParams) {
        throw new Error(
          'Parameter `batchAssignUserIdsParams` is required when calling `batchAssignUserIds`.'
        );
      }

      if (!batchAssignUserIdsParams.cluster) {
        throw new Error(
          'Parameter `batchAssignUserIdsParams.cluster` is required when calling `batchAssignUserIds`.'
        );
      }
      if (!batchAssignUserIdsParams.users) {
        throw new Error(
          'Parameter `batchAssignUserIdsParams.users` is required when calling `batchAssignUserIds`.'
        );
      }

      const requestPath = '/1/clusters/mapping/batch';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (xAlgoliaUserID !== undefined) {
        headers['X-Algolia-User-ID'] = xAlgoliaUserID.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: batchAssignUserIdsParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Add or remove a batch of dictionary entries.
     *
     * @summary Batch dictionary entries.
     * @param batchDictionaryEntries - The batchDictionaryEntries object.
     * @param batchDictionaryEntries.dictionaryName - Dictionary to search in.
     * @param batchDictionaryEntries.batchDictionaryEntriesParams - The batchDictionaryEntriesParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    batchDictionaryEntries(
      {
        dictionaryName,
        batchDictionaryEntriesParams,
      }: BatchDictionaryEntriesProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!dictionaryName) {
        throw new Error(
          'Parameter `dictionaryName` is required when calling `batchDictionaryEntries`.'
        );
      }

      if (!batchDictionaryEntriesParams) {
        throw new Error(
          'Parameter `batchDictionaryEntriesParams` is required when calling `batchDictionaryEntries`.'
        );
      }

      if (!batchDictionaryEntriesParams.requests) {
        throw new Error(
          'Parameter `batchDictionaryEntriesParams.requests` is required when calling `batchDictionaryEntries`.'
        );
      }

      const requestPath = '/1/dictionaries/{dictionaryName}/batch'.replace(
        '{dictionaryName}',
        encodeURIComponent(dictionaryName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: batchDictionaryEntriesParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn\'t support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.
     *
     * @summary Get all records from an index.
     * @param browse - The browse object.
     * @param browse.indexName - Index on which to perform the request.
     * @param browse.browseParams - The browseParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    browse<T>(
      { indexName, browseParams }: BrowseProps,
      requestOptions?: RequestOptions
    ): Promise<BrowseResponse<T>> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `browse`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/browse'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: browseParams ? browseParams : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Delete all synonyms in the index.
     *
     * @summary Delete all synonyms.
     * @param clearAllSynonyms - The clearAllSynonyms object.
     * @param clearAllSynonyms.indexName - Index on which to perform the request.
     * @param clearAllSynonyms.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    clearAllSynonyms(
      { indexName, forwardToReplicas }: ClearAllSynonymsProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `clearAllSynonyms`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/synonyms/clear'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Delete the records but leave settings and index-specific API keys untouched.
     *
     * @summary Delete all records from an index.
     * @param clearObjects - The clearObjects object.
     * @param clearObjects.indexName - Index on which to perform the request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    clearObjects(
      { indexName }: ClearObjectsProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `clearObjects`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/clear'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Delete all rules in the index.
     *
     * @summary Delete all rules.
     * @param clearRules - The clearRules object.
     * @param clearRules.indexName - Index on which to perform the request.
     * @param clearRules.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    clearRules(
      { indexName, forwardToReplicas }: ClearRulesProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `clearRules`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/rules/clear'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @summary Send requests to the Algolia REST API.
     * @param del - The del object.
     * @param del.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param del.parameters - Query parameters to apply to the current query.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    del(
      { path, parameters }: DelProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `del`.');
      }

      const requestPath = '/1{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Delete an existing API key. The request must be authenticated with the admin API key.
     *
     * @summary Delete API key.
     * @param deleteApiKey - The deleteApiKey object.
     * @param deleteApiKey.key - API key.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteApiKey(
      { key }: DeleteApiKeyProps,
      requestOptions?: RequestOptions
    ): Promise<DeleteApiKeyResponse> {
      if (!key) {
        throw new Error(
          'Parameter `key` is required when calling `deleteApiKey`.'
        );
      }

      const requestPath = '/1/keys/{key}'.replace(
        '{key}',
        encodeURIComponent(key)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This operation doesn\'t support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn\'t accept empty filters or queries.
     *
     * @summary Delete all records matching a query.
     * @param deleteBy - The deleteBy object.
     * @param deleteBy.indexName - Index on which to perform the request.
     * @param deleteBy.deleteByParams - The deleteByParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteBy(
      { indexName, deleteByParams }: DeleteByProps,
      requestOptions?: RequestOptions
    ): Promise<DeletedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `deleteBy`.'
        );
      }

      if (!deleteByParams) {
        throw new Error(
          'Parameter `deleteByParams` is required when calling `deleteBy`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/deleteByQuery'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: deleteByParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Delete an existing index.
     *
     * @summary Delete index.
     * @param deleteIndex - The deleteIndex object.
     * @param deleteIndex.indexName - Index on which to perform the request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteIndex(
      { indexName }: DeleteIndexProps,
      requestOptions?: RequestOptions
    ): Promise<DeletedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `deleteIndex`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.
     *
     * @summary Delete a record.
     * @param deleteObject - The deleteObject object.
     * @param deleteObject.indexName - Index on which to perform the request.
     * @param deleteObject.objectID - Unique record (object) identifier.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteObject(
      { indexName, objectID }: DeleteObjectProps,
      requestOptions?: RequestOptions
    ): Promise<DeletedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `deleteObject`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `deleteObject`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
     *
     * @summary Delete a rule.
     * @param deleteRule - The deleteRule object.
     * @param deleteRule.indexName - Index on which to perform the request.
     * @param deleteRule.objectID - Unique identifier of a rule object.
     * @param deleteRule.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteRule(
      { indexName, objectID, forwardToReplicas }: DeleteRuleProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `deleteRule`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `deleteRule`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/rules/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Remove a source from the list of allowed sources.
     *
     * @summary Remove a source.
     * @param deleteSource - The deleteSource object.
     * @param deleteSource.source - IP address range of the source.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteSource(
      { source }: DeleteSourceProps,
      requestOptions?: RequestOptions
    ): Promise<DeleteSourceResponse> {
      if (!source) {
        throw new Error(
          'Parameter `source` is required when calling `deleteSource`.'
        );
      }

      const requestPath = '/1/security/sources/{source}'.replace(
        '{source}',
        encodeURIComponent(source)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
     *
     * @summary Delete a synonym.
     * @param deleteSynonym - The deleteSynonym object.
     * @param deleteSynonym.indexName - Index on which to perform the request.
     * @param deleteSynonym.objectID - Unique identifier of a synonym object.
     * @param deleteSynonym.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    deleteSynonym(
      { indexName, objectID, forwardToReplicas }: DeleteSynonymProps,
      requestOptions?: RequestOptions
    ): Promise<DeletedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `deleteSynonym`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `deleteSynonym`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/synonyms/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @summary Send requests to the Algolia REST API.
     * @param get - The get object.
     * @param get.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param get.parameters - Query parameters to apply to the current query.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    get(
      { path, parameters }: GetProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `get`.');
      }

      const requestPath = '/1{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application\'s keys. When authenticating with other API keys, you can only retrieve information for that key.
     *
     * @summary Get API key permissions.
     * @param getApiKey - The getApiKey object.
     * @param getApiKey.key - API key.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getApiKey(
      { key }: GetApiKeyProps,
      requestOptions?: RequestOptions
    ): Promise<GetApiKeyResponse> {
      if (!key) {
        throw new Error(
          'Parameter `key` is required when calling `getApiKey`.'
        );
      }

      const requestPath = '/1/keys/{key}'.replace(
        '{key}',
        encodeURIComponent(key)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Lists Algolia\'s [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language\'s [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
     *
     * @summary List available languages.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getDictionaryLanguages(
      requestOptions?: RequestOptions
    ): Promise<Record<string, Languages>> {
      const requestPath = '/1/dictionaries/*/languages';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
     *
     * @summary Get stop word settings.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getDictionarySettings(
      requestOptions?: RequestOptions
    ): Promise<GetDictionarySettingsResponse> {
      const requestPath = '/1/dictionaries/*/settings';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There\'s also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn\'t appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN\'s endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
     *
     * @summary Return the latest log entries.
     * @param getLogs - The getLogs object.
     * @param getLogs.offset - First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
     * @param getLogs.length - Maximum number of entries to retrieve.
     * @param getLogs.indexName - Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
     * @param getLogs.type - Type of log entries to retrieve. When omitted, all log entries are retrieved.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getLogs(
      { offset, length, indexName, type }: GetLogsProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<GetLogsResponse> {
      const requestPath = '/1/logs';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (offset !== undefined) {
        queryParameters.offset = offset.toString();
      }

      if (length !== undefined) {
        queryParameters.length = length.toString();
      }

      if (indexName !== undefined) {
        queryParameters.indexName = indexName.toString();
      }

      if (type !== undefined) {
        queryParameters.type = type.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
     *
     * @summary Get a record.
     * @param getObject - The getObject object.
     * @param getObject.indexName - Index on which to perform the request.
     * @param getObject.objectID - Unique record (object) identifier.
     * @param getObject.attributesToRetrieve - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won\'t be retrieved unless the request is authenticated with the admin API key.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getObject(
      { indexName, objectID, attributesToRetrieve }: GetObjectProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, string>> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `getObject`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `getObject`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (attributesToRetrieve !== undefined) {
        queryParameters.attributesToRetrieve = attributesToRetrieve.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.
     *
     * @summary Get multiple records.
     * @param getObjectsParams - Request object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getObjects<T>(
      getObjectsParams: GetObjectsParams,
      requestOptions?: RequestOptions
    ): Promise<GetObjectsResponse<T>> {
      if (!getObjectsParams) {
        throw new Error(
          'Parameter `getObjectsParams` is required when calling `getObjects`.'
        );
      }

      if (!getObjectsParams.requests) {
        throw new Error(
          'Parameter `getObjectsParams.requests` is required when calling `getObjects`.'
        );
      }

      const requestPath = '/1/indexes/*/objects';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: getObjectsParams,
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
     *
     * @summary Get a rule.
     * @param getRule - The getRule object.
     * @param getRule.indexName - Index on which to perform the request.
     * @param getRule.objectID - Unique identifier of a rule object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getRule(
      { indexName, objectID }: GetRuleProps,
      requestOptions?: RequestOptions
    ): Promise<Rule> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `getRule`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `getRule`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/rules/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Return an object containing an index\'s [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
     *
     * @summary Get index settings.
     * @param getSettings - The getSettings object.
     * @param getSettings.indexName - Index on which to perform the request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getSettings(
      { indexName }: GetSettingsProps,
      requestOptions?: RequestOptions
    ): Promise<IndexSettings> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `getSettings`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/settings'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Get all allowed sources (IP addresses).
     *
     * @summary Get all allowed IP addresses.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getSources(requestOptions?: RequestOptions): Promise<Source[]> {
      const requestPath = '/1/security/sources';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
     *
     * @summary Get a synonym object.
     * @param getSynonym - The getSynonym object.
     * @param getSynonym.indexName - Index on which to perform the request.
     * @param getSynonym.objectID - Unique identifier of a synonym object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getSynonym(
      { indexName, objectID }: GetSynonymProps,
      requestOptions?: RequestOptions
    ): Promise<SynonymHit> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `getSynonym`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `getSynonym`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/synonyms/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.
     *
     * @summary Check a task\'s status.
     * @param getTask - The getTask object.
     * @param getTask.indexName - Index on which to perform the request.
     * @param getTask.taskID - Unique task identifier.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTask(
      { indexName, taskID }: GetTaskProps,
      requestOptions?: RequestOptions
    ): Promise<GetTaskResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `getTask`.'
        );
      }

      if (!taskID) {
        throw new Error(
          'Parameter `taskID` is required when calling `getTask`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/task/{taskID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{taskID}', encodeURIComponent(taskID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn\'t real-time.
     *
     * @summary Get top userID.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getTopUserIds(
      requestOptions?: RequestOptions
    ): Promise<GetTopUserIdsResponse> {
      const requestPath = '/1/clusters/mapping/top';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn\'t real-time.
     *
     * @summary Get userID.
     * @param getUserId - The getUserId object.
     * @param getUserId.userID - UserID to assign.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    getUserId(
      { userID }: GetUserIdProps,
      requestOptions?: RequestOptions
    ): Promise<UserId> {
      if (!userID) {
        throw new Error(
          'Parameter `userID` is required when calling `getUserId`.'
        );
      }

      const requestPath = '/1/clusters/mapping/{userID}'.replace(
        '{userID}',
        encodeURIComponent(userID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
     *
     * @summary Get migration and user mapping status.
     * @param hasPendingMappings - The hasPendingMappings object.
     * @param hasPendingMappings.getClusters - Indicates whether to include the cluster\'s pending mapping state in the response.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    hasPendingMappings(
      { getClusters }: HasPendingMappingsProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<HasPendingMappingsResponse> {
      const requestPath = '/1/clusters/mapping/pending';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (getClusters !== undefined) {
        queryParameters.getClusters = getClusters.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * List all API keys associated with your Algolia application, including their permissions and restrictions.
     *
     * @summary List API keys.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listApiKeys(requestOptions?: RequestOptions): Promise<ListApiKeysResponse> {
      const requestPath = '/1/keys';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * List the available clusters in a multi-cluster setup.
     *
     * @summary List clusters.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listClusters(
      requestOptions?: RequestOptions
    ): Promise<ListClustersResponse> {
      const requestPath = '/1/clusters';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * List indices in an Algolia application.
     *
     * @summary List indices.
     * @param listIndices - The listIndices object.
     * @param listIndices.page - Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
     * @param listIndices.hitsPerPage - Maximum number of hits per page.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listIndices(
      { page, hitsPerPage }: ListIndicesProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<ListIndicesResponse> {
      const requestPath = '/1/indexes';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (hitsPerPage !== undefined) {
        queryParameters.hitsPerPage = hitsPerPage.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn\'t real-time.
     *
     * @summary List userIDs.
     * @param listUserIds - The listUserIds object.
     * @param listUserIds.page - Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
     * @param listUserIds.hitsPerPage - Maximum number of hits per page.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    listUserIds(
      { page, hitsPerPage }: ListUserIdsProps = {},
      requestOptions: RequestOptions | undefined = undefined
    ): Promise<ListUserIdsResponse> {
      const requestPath = '/1/clusters/mapping';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (hitsPerPage !== undefined) {
        queryParameters.hitsPerPage = hitsPerPage.toString();
      }

      const request: Request = {
        method: 'GET',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * To reduce the time spent on network round trips, you can perform several write actions in a single request. It\'s a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.
     *
     * @summary Batch write operations on multiple indices.
     * @param batchParams - The batchParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    multipleBatch(
      batchParams: BatchParams,
      requestOptions?: RequestOptions
    ): Promise<MultipleBatchResponse> {
      if (!batchParams) {
        throw new Error(
          'Parameter `batchParams` is required when calling `multipleBatch`.'
        );
      }

      if (!batchParams.requests) {
        throw new Error(
          'Parameter `batchParams.requests` is required when calling `multipleBatch`.'
        );
      }

      const requestPath = '/1/indexes/*/batch';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: batchParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This `operation`, _copy_ or _move_, will copy or move a source index\'s (`IndexName`) records, settings, synonyms, and rules to a `destination` index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn\'t exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
     *
     * @summary Copy, move, or rename an index.
     * @param operationIndex - The operationIndex object.
     * @param operationIndex.indexName - Index on which to perform the request.
     * @param operationIndex.operationIndexParams - The operationIndexParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    operationIndex(
      { indexName, operationIndexParams }: OperationIndexProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `operationIndex`.'
        );
      }

      if (!operationIndexParams) {
        throw new Error(
          'Parameter `operationIndexParams` is required when calling `operationIndex`.'
        );
      }

      if (!operationIndexParams.operation) {
        throw new Error(
          'Parameter `operationIndexParams.operation` is required when calling `operationIndex`.'
        );
      }
      if (!operationIndexParams.destination) {
        throw new Error(
          'Parameter `operationIndexParams.destination` is required when calling `operationIndex`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/operation'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: operationIndexParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.
     *
     * @summary Update record attributes.
     * @param partialUpdateObject - The partialUpdateObject object.
     * @param partialUpdateObject.indexName - Index on which to perform the request.
     * @param partialUpdateObject.objectID - Unique record (object) identifier.
     * @param partialUpdateObject.attributesToUpdate - Object with attributes to update.
     * @param partialUpdateObject.createIfNotExists - Indicates whether to create a new record if it doesn\'t exist yet.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    partialUpdateObject(
      {
        indexName,
        objectID,
        attributesToUpdate,
        createIfNotExists,
      }: PartialUpdateObjectProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtWithObjectIdResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `partialUpdateObject`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `partialUpdateObject`.'
        );
      }

      if (!attributesToUpdate) {
        throw new Error(
          'Parameter `attributesToUpdate` is required when calling `partialUpdateObject`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/{objectID}/partial'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (createIfNotExists !== undefined) {
        queryParameters.createIfNotExists = createIfNotExists.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: attributesToUpdate,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @summary Send requests to the Algolia REST API.
     * @param post - The post object.
     * @param post.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param post.parameters - Query parameters to apply to the current query.
     * @param post.body - Parameters to send with the custom request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    post(
      { path, parameters, body }: PostProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `post`.');
      }

      const requestPath = '/1{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @summary Send requests to the Algolia REST API.
     * @param put - The put object.
     * @param put.path - Path of the endpoint, anything after \"/1\" must be specified.
     * @param put.parameters - Query parameters to apply to the current query.
     * @param put.body - Parameters to send with the custom request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    put(
      { path, parameters, body }: PutProps,
      requestOptions?: RequestOptions
    ): Promise<Record<string, any>> {
      if (!path) {
        throw new Error('Parameter `path` is required when calling `put`.');
      }

      const requestPath = '/1{path}'.replace('{path}', path);
      const headers: Headers = {};
      const queryParameters: QueryParameters = parameters ? parameters : {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {},
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Remove a userID and its associated data from the multi-clusters.
     *
     * @summary Remove userID.
     * @param removeUserId - The removeUserId object.
     * @param removeUserId.userID - UserID to assign.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    removeUserId(
      { userID }: RemoveUserIdProps,
      requestOptions?: RequestOptions
    ): Promise<RemoveUserIdResponse> {
      if (!userID) {
        throw new Error(
          'Parameter `userID` is required when calling `removeUserId`.'
        );
      }

      const requestPath = '/1/clusters/mapping/{userID}'.replace(
        '{userID}',
        encodeURIComponent(userID)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'DELETE',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Replace all allowed sources.
     *
     * @summary Replace all sources.
     * @param replaceSources - The replaceSources object.
     * @param replaceSources.source - Allowed sources.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    replaceSources(
      { source }: ReplaceSourcesProps,
      requestOptions?: RequestOptions
    ): Promise<ReplaceSourceResponse> {
      if (!source) {
        throw new Error(
          'Parameter `source` is required when calling `replaceSources`.'
        );
      }

      const requestPath = '/1/security/sources';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: source,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.
     *
     * @summary Restore API key.
     * @param restoreApiKey - The restoreApiKey object.
     * @param restoreApiKey.key - API key.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    restoreApiKey(
      { key }: RestoreApiKeyProps,
      requestOptions?: RequestOptions
    ): Promise<AddApiKeyResponse> {
      if (!key) {
        throw new Error(
          'Parameter `key` is required when calling `restoreApiKey`.'
        );
      }

      const requestPath = '/1/keys/{key}/restore'.replace(
        '{key}',
        encodeURIComponent(key)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Add a record (object) to an index or replace it. If the record doesn\'t contain an `objectID`, Algolia automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
     *
     * @summary Add or update a record.
     * @param saveObject - The saveObject object.
     * @param saveObject.indexName - Index on which to perform the request.
     * @param saveObject.body - The Algolia record.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    saveObject(
      { indexName, body }: SaveObjectProps,
      requestOptions?: RequestOptions
    ): Promise<SaveObjectResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `saveObject`.'
        );
      }

      if (!body) {
        throw new Error(
          'Parameter `body` is required when calling `saveObject`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: body,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
     *
     * @summary Create or update a rule.
     * @param saveRule - The saveRule object.
     * @param saveRule.indexName - Index on which to perform the request.
     * @param saveRule.objectID - Unique identifier of a rule object.
     * @param saveRule.rule - The rule object.
     * @param saveRule.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    saveRule(
      { indexName, objectID, rule, forwardToReplicas }: SaveRuleProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedRuleResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `saveRule`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `saveRule`.'
        );
      }

      if (!rule) {
        throw new Error(
          'Parameter `rule` is required when calling `saveRule`.'
        );
      }

      if (!rule.objectID) {
        throw new Error(
          'Parameter `rule.objectID` is required when calling `saveRule`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/rules/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: rule,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Create or update multiple rules.
     *
     * @summary Save a batch of rules.
     * @param saveRules - The saveRules object.
     * @param saveRules.indexName - Index on which to perform the request.
     * @param saveRules.rules - The rules object.
     * @param saveRules.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param saveRules.clearExistingRules - Indicates whether existing rules should be deleted before adding this batch.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    saveRules(
      {
        indexName,
        rules,
        forwardToReplicas,
        clearExistingRules,
      }: SaveRulesProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `saveRules`.'
        );
      }

      if (!rules) {
        throw new Error(
          'Parameter `rules` is required when calling `saveRules`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/rules/batch'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      if (clearExistingRules !== undefined) {
        queryParameters.clearExistingRules = clearExistingRules.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: rules,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym `objectID` doesn\'t exist, Algolia adds a new one. If you use an existing synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
     *
     * @summary Save a synonym.
     * @param saveSynonym - The saveSynonym object.
     * @param saveSynonym.indexName - Index on which to perform the request.
     * @param saveSynonym.objectID - Unique identifier of a synonym object.
     * @param saveSynonym.synonymHit - The synonymHit object.
     * @param saveSynonym.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    saveSynonym(
      { indexName, objectID, synonymHit, forwardToReplicas }: SaveSynonymProps,
      requestOptions?: RequestOptions
    ): Promise<SaveSynonymResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `saveSynonym`.'
        );
      }

      if (!objectID) {
        throw new Error(
          'Parameter `objectID` is required when calling `saveSynonym`.'
        );
      }

      if (!synonymHit) {
        throw new Error(
          'Parameter `synonymHit` is required when calling `saveSynonym`.'
        );
      }

      if (!synonymHit.objectID) {
        throw new Error(
          'Parameter `synonymHit.objectID` is required when calling `saveSynonym`.'
        );
      }
      if (!synonymHit.type) {
        throw new Error(
          'Parameter `synonymHit.type` is required when calling `saveSynonym`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/synonyms/{objectID}'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{objectID}', encodeURIComponent(objectID));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: synonymHit,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Create or update multiple synonyms.
     *
     * @summary Save a batch of synonyms.
     * @param saveSynonyms - The saveSynonyms object.
     * @param saveSynonyms.indexName - Index on which to perform the request.
     * @param saveSynonyms.synonymHit - The synonymHit object.
     * @param saveSynonyms.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param saveSynonyms.replaceExistingSynonyms - Indicates whether to replace all synonyms in the index with the ones sent with this request.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    saveSynonyms(
      {
        indexName,
        synonymHit,
        forwardToReplicas,
        replaceExistingSynonyms,
      }: SaveSynonymsProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `saveSynonyms`.'
        );
      }

      if (!synonymHit) {
        throw new Error(
          'Parameter `synonymHit` is required when calling `saveSynonyms`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/synonyms/batch'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      if (replaceExistingSynonyms !== undefined) {
        queryParameters.replaceExistingSynonyms =
          replaceExistingSynonyms.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: synonymHit,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Send multiple search queries to one or more indices.
     *
     * @summary Search multiple indices.
     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    search(
      searchMethodParams: LegacySearchMethodProps | SearchMethodParams,
      requestOptions?: RequestOptions
    ): Promise<SearchResponses> {
      if (searchMethodParams && Array.isArray(searchMethodParams)) {
        const newSignatureRequest: SearchMethodParams = {
          requests: searchMethodParams.map(({ params, ...legacyRequest }) => {
            if (legacyRequest.type === 'facet') {
              return {
                ...legacyRequest,
                ...params,
                type: 'facet',
              };
            }

            return {
              ...legacyRequest,
              ...params,
              facet: undefined,
              maxFacetHits: undefined,
              facetQuery: undefined,
            };
          }),
        };

        // eslint-disable-next-line no-param-reassign
        searchMethodParams = newSignatureRequest;
      }

      if (!searchMethodParams) {
        throw new Error(
          'Parameter `searchMethodParams` is required when calling `search`.'
        );
      }

      if (!searchMethodParams.requests) {
        throw new Error(
          'Parameter `searchMethodParams.requests` is required when calling `search`.'
        );
      }

      const requestPath = '/1/indexes/*/queries';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: searchMethodParams,
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
     *
     * @summary Search dictionary entries.
     * @param searchDictionaryEntries - The searchDictionaryEntries object.
     * @param searchDictionaryEntries.dictionaryName - Dictionary to search in.
     * @param searchDictionaryEntries.searchDictionaryEntriesParams - The searchDictionaryEntriesParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchDictionaryEntries(
      {
        dictionaryName,
        searchDictionaryEntriesParams,
      }: SearchDictionaryEntriesProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!dictionaryName) {
        throw new Error(
          'Parameter `dictionaryName` is required when calling `searchDictionaryEntries`.'
        );
      }

      if (!searchDictionaryEntriesParams) {
        throw new Error(
          'Parameter `searchDictionaryEntriesParams` is required when calling `searchDictionaryEntries`.'
        );
      }

      if (!searchDictionaryEntriesParams.query) {
        throw new Error(
          'Parameter `searchDictionaryEntriesParams.query` is required when calling `searchDictionaryEntries`.'
        );
      }

      const requestPath = '/1/dictionaries/{dictionaryName}/search'.replace(
        '{dictionaryName}',
        encodeURIComponent(dictionaryName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: searchDictionaryEntriesParams,
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * [Search for a facet\'s values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. > **Note**: Pagination isn\'t supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.
     *
     * @summary Search for facet values.
     * @param searchForFacetValues - The searchForFacetValues object.
     * @param searchForFacetValues.indexName - Index on which to perform the request.
     * @param searchForFacetValues.facetName - Facet name.
     * @param searchForFacetValues.searchForFacetValuesRequest - The searchForFacetValuesRequest object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchForFacetValues(
      {
        indexName,
        facetName,
        searchForFacetValuesRequest,
      }: SearchForFacetValuesProps,
      requestOptions?: RequestOptions
    ): Promise<SearchForFacetValuesResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `searchForFacetValues`.'
        );
      }

      if (!facetName) {
        throw new Error(
          'Parameter `facetName` is required when calling `searchForFacetValues`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/facets/{facetName}/query'
        .replace('{indexName}', encodeURIComponent(indexName))
        .replace('{facetName}', encodeURIComponent(facetName));
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: searchForFacetValuesRequest ? searchForFacetValuesRequest : {},
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
     *
     * @summary Search for rules.
     * @param searchRules - The searchRules object.
     * @param searchRules.indexName - Index on which to perform the request.
     * @param searchRules.searchRulesParams - The searchRulesParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchRules(
      { indexName, searchRulesParams }: SearchRulesProps,
      requestOptions?: RequestOptions
    ): Promise<SearchRulesResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `searchRules`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/rules/search'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: searchRulesParams ? searchRulesParams : {},
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Return records that match the query.
     *
     * @summary Search an index.
     * @param searchSingleIndex - The searchSingleIndex object.
     * @param searchSingleIndex.indexName - Index on which to perform the request.
     * @param searchSingleIndex.searchParams - The searchParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchSingleIndex<T>(
      { indexName, searchParams }: SearchSingleIndexProps,
      requestOptions?: RequestOptions
    ): Promise<SearchResponse<T>> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `searchSingleIndex`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/query'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: searchParams ? searchParams : {},
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
     *
     * @summary Search for synonyms.
     * @param searchSynonyms - The searchSynonyms object.
     * @param searchSynonyms.indexName - Index on which to perform the request.
     * @param searchSynonyms.type - Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
     * @param searchSynonyms.page - Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there\'s no pagination.
     * @param searchSynonyms.hitsPerPage - Maximum number of hits per page.
     * @param searchSynonyms.searchSynonymsParams - Body of the `searchSynonyms` operation.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchSynonyms(
      {
        indexName,
        type,
        page,
        hitsPerPage,
        searchSynonymsParams,
      }: SearchSynonymsProps,
      requestOptions?: RequestOptions
    ): Promise<SearchSynonymsResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `searchSynonyms`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/synonyms/search'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (type !== undefined) {
        queryParameters.type = type.toString();
      }

      if (page !== undefined) {
        queryParameters.page = page.toString();
      }

      if (hitsPerPage !== undefined) {
        queryParameters.hitsPerPage = hitsPerPage.toString();
      }

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: searchSynonymsParams ? searchSynonymsParams : {},
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Since it can take up to a few seconds to get the data from the different clusters, the response isn\'t real-time. To ensure rapid updates, the user IDs index isn\'t built at the same time as the mapping. Instead, it\'s built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
     *
     * @summary Search for a user ID.
     * @param searchUserIdsParams - The searchUserIdsParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    searchUserIds(
      searchUserIdsParams: SearchUserIdsParams,
      requestOptions?: RequestOptions
    ): Promise<SearchUserIdsResponse> {
      if (!searchUserIdsParams) {
        throw new Error(
          'Parameter `searchUserIdsParams` is required when calling `searchUserIds`.'
        );
      }

      if (!searchUserIdsParams.query) {
        throw new Error(
          'Parameter `searchUserIdsParams.query` is required when calling `searchUserIds`.'
        );
      }

      const requestPath = '/1/clusters/mapping/search';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'POST',
        path: requestPath,
        queryParameters,
        headers,
        data: searchUserIdsParams,
        useReadTransporter: true,
        cacheable: true,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Set stop word settings for a specific language.
     *
     * @summary Set stop word settings.
     * @param dictionarySettingsParams - The dictionarySettingsParams object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    setDictionarySettings(
      dictionarySettingsParams: DictionarySettingsParams,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!dictionarySettingsParams) {
        throw new Error(
          'Parameter `dictionarySettingsParams` is required when calling `setDictionarySettings`.'
        );
      }

      if (!dictionarySettingsParams.disableStandardEntries) {
        throw new Error(
          'Parameter `dictionarySettingsParams.disableStandardEntries` is required when calling `setDictionarySettings`.'
        );
      }

      const requestPath = '/1/dictionaries/*/settings';
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: dictionarySettingsParams,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
     *
     * @summary Update index settings.
     * @param setSettings - The setSettings object.
     * @param setSettings.indexName - Index on which to perform the request.
     * @param setSettings.indexSettings - The indexSettings object.
     * @param setSettings.forwardToReplicas - Indicates whether changed index settings are forwarded to the replica indices.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    setSettings(
      { indexName, indexSettings, forwardToReplicas }: SetSettingsProps,
      requestOptions?: RequestOptions
    ): Promise<UpdatedAtResponse> {
      if (!indexName) {
        throw new Error(
          'Parameter `indexName` is required when calling `setSettings`.'
        );
      }

      if (!indexSettings) {
        throw new Error(
          'Parameter `indexSettings` is required when calling `setSettings`.'
        );
      }

      const requestPath = '/1/indexes/{indexName}/settings'.replace(
        '{indexName}',
        encodeURIComponent(indexName)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      if (forwardToReplicas !== undefined) {
        queryParameters.forwardToReplicas = forwardToReplicas.toString();
      }

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: indexSettings,
      };

      return transporter.request(request, requestOptions);
    },

    /**
     * Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.
     *
     * @summary Update an API key.
     * @param updateApiKey - The updateApiKey object.
     * @param updateApiKey.key - API key.
     * @param updateApiKey.apiKey - The apiKey object.
     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
     */
    updateApiKey(
      { key, apiKey }: UpdateApiKeyProps,
      requestOptions?: RequestOptions
    ): Promise<UpdateApiKeyResponse> {
      if (!key) {
        throw new Error(
          'Parameter `key` is required when calling `updateApiKey`.'
        );
      }

      if (!apiKey) {
        throw new Error(
          'Parameter `apiKey` is required when calling `updateApiKey`.'
        );
      }

      if (!apiKey.acl) {
        throw new Error(
          'Parameter `apiKey.acl` is required when calling `updateApiKey`.'
        );
      }

      const requestPath = '/1/keys/{key}'.replace(
        '{key}',
        encodeURIComponent(key)
      );
      const headers: Headers = {};
      const queryParameters: QueryParameters = {};

      const request: Request = {
        method: 'PUT',
        path: requestPath,
        queryParameters,
        headers,
        data: apiKey,
      };

      return transporter.request(request, requestOptions);
    },
  };
}

/**
 * The client type.
 */
export type SearchClient = ReturnType<typeof createSearchClient>;
